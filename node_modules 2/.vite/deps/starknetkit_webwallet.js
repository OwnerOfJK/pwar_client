import {
  A,
  F,
  R,
  S,
  S2,
  U,
  W,
  k,
  q
} from "./chunk-LYYFFJZR.js";
import {
  Account,
  constants_exports
} from "./chunk-QDHGGQX4.js";
import "./chunk-FZTRGRHO.js";
import "./chunk-PHMCJWRI.js";
import "./chunk-V4OQ3NZ2.js";

// ../node_modules/.pnpm/starknetkit@2.6.1_starknet@6.21.0/node_modules/starknetkit/dist/index-34c090a8.js
var En = Object.defineProperty;
var Cn = (t, e, r) => e in t ? En(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var pt = (t, e, r) => (Cn(t, typeof e != "symbol" ? e + "" : e, r), r);
var kr = "https://web.argent.xyz";
var rr = `<svg
    width="32"
    height="28"
    viewBox="0 0 18 14"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M1.5 0.4375C0.982233 0.4375 0.5625 0.857233 0.5625 1.375V12C0.5625 12.4144 0.72712 12.8118 1.02015 13.1049C1.31317 13.3979 1.7106 13.5625 2.125 13.5625H15.875C16.2894 13.5625 16.6868 13.3979 16.9799 13.1049C17.2729 12.8118 17.4375 12.4144 17.4375 12V1.375C17.4375 0.857233 17.0178 0.4375 16.5 0.4375H1.5ZM2.4375 3.50616V11.6875H15.5625V3.50616L9.63349 8.94108C9.27507 9.26964 8.72493 9.26964 8.36651 8.94108L2.4375 3.50616ZM14.0899 2.3125H3.91013L9 6.97822L14.0899 2.3125Z"
      fill="currentColor"
    />
  </svg>`;
var Pn = "https://static.hydrogen.argent47.net/webwallet/iframe_whitelist_testnet.json";
var Nn = "https://static.argent.net/webwallet/iframe_whitelist_mainnet.json";
var le = constants_exports.NetworkName;
var In = le.SN_SEPOLIA;
function jn(t) {
  try {
    const { origin: e } = new URL(t);
    if (e.includes("localhost") || e.includes("127.0.0.1"))
      return In;
    if (e.includes("hydrogen"))
      return le.SN_SEPOLIA;
    if (e.includes("staging"))
      return le.SN_MAIN;
    if (e.includes("dev"))
      return le.SN_SEPOLIA;
    if (e.includes("argent.xyz"))
      return le.SN_MAIN;
  } catch {
    console.warn(
      "Could not determine network from target URL, defaulting to mainnet-alpha"
    );
  }
  return le.SN_MAIN;
}
var An = 385;
var Ln = 775;
var $n = 385;
var Mn = 440;
function Dn(t) {
  return t;
}
function Zn(t) {
  return t.length === 0 ? Dn : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function Un(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function rt(t) {
  const e = {
    subscribe(r) {
      let n = null, s = false, a = false, i = false;
      function o() {
        if (n === null) {
          i = true;
          return;
        }
        a || (a = true, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          s || r.next?.(c);
        },
        error(c) {
          s || (s = true, r.error?.(c), o());
        },
        complete() {
          s || (s = true, r.complete?.(), o());
        }
      }), i && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return Zn(r)(e);
    }
  };
  return e;
}
function Tr(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function a() {
      n || (n = e.subscribe({
        next(o) {
          for (const c of s)
            c.next?.(o);
        },
        error(o) {
          for (const c of s)
            c.error?.(o);
        },
        complete() {
          for (const o of s)
            o.complete?.();
        }
      }));
    }
    function i() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), a(), {
          unsubscribe() {
            r--, i();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function Wn(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(a) {
          r.next?.(t(a, n++));
        },
        error(a) {
          r.error?.(a);
        },
        complete() {
          r.complete?.();
        }
      });
    }
  });
}
function Er(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          t.next?.(n), r.next?.(n);
        },
        error(n) {
          t.error?.(n), r.error?.(n);
        },
        complete() {
          t.complete?.(), r.complete?.();
        }
      });
    }
  });
}
var qn = class Cr extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, Cr.prototype);
  }
};
function Rr(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let a = false;
      function i() {
        a || (a = true, s(new qn("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          a = true, n(c), i();
        },
        error(c) {
          a = true, s(c), i();
        },
        complete() {
          a = true, i();
        }
      });
      e = i;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
var zn = Object.freeze(Object.defineProperty({
  __proto__: null,
  isObservable: Un,
  map: Wn,
  observable: rt,
  observableToPromise: Rr,
  share: Tr,
  tap: Er
}, Symbol.toStringTag, { value: "Module" }));
function Or(t) {
  return rt((e) => {
    function r(s = 0, a = t.op) {
      const i = t.links[s];
      if (!i)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return i({
        op: a,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function nr(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function Bn(t) {
  return (e) => {
    const r = nr(t.true).map((s) => s(e)), n = nr(t.false).map((s) => s(e));
    return (s) => rt((a) => {
      const i = t.condition(s.op) ? r : n;
      return Or({
        op: s.op,
        links: i
      }).subscribe(a);
    });
  };
}
function Sr(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const r in t) {
    const n = t[r];
    e[n] = r;
  }
  return e;
}
var nt = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
Sr(nt);
Sr(nt);
var Vn = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function Hn(t) {
  return Vn[t] ?? 500;
}
function Pr(t) {
  return Hn(t.code);
}
var Nr = () => {
};
function Ir(t, e) {
  return new Proxy(Nr, {
    get(n, s) {
      if (!(typeof s != "string" || s === "then"))
        return Ir(t, [
          ...e,
          s
        ]);
    },
    apply(n, s, a) {
      const i = e[e.length - 1] === "apply";
      return t({
        args: i ? a.length >= 2 ? a[1] : [] : a,
        path: i ? e.slice(0, -1) : e
      });
    }
  });
}
var Dt = (t) => Ir(t, []);
var Zt = (t) => new Proxy(Nr, {
  get(e, r) {
    if (!(typeof r != "string" || r === "then"))
      return t(r);
  }
});
function Fn(t) {
  const { path: e, error: r, config: n } = t, { code: s } = t.error, a = {
    message: r.message,
    code: nt[s],
    data: {
      code: s,
      httpStatus: Pr(r)
    }
  };
  return n.isDev && typeof t.error.stack == "string" && (a.data.stack = t.error.stack), typeof e == "string" && (a.data.path = e), n.errorFormatter({
    ...t,
    shape: a
  });
}
function sr(t, e) {
  return "error" in e ? {
    ...e,
    error: t.transformer.output.serialize(e.error)
  } : "data" in e.result ? {
    ...e,
    result: {
      ...e.result,
      data: t.transformer.output.serialize(e.result.data)
    }
  } : e;
}
function Jn(t, e) {
  return Array.isArray(e) ? e.map((r) => sr(t, r)) : sr(t, e);
}
function Gn(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
var Yn = class extends Error {
};
function Ut(t) {
  if (t instanceof Error)
    return t;
  const e = typeof t;
  if (!(e === "undefined" || e === "function" || t === null)) {
    if (e !== "object")
      return new Error(String(t));
    if (Gn(t)) {
      const r = new Yn();
      for (const n in t)
        r[n] = t[n];
      return r;
    }
  }
}
var Xn = Object.freeze(Object.defineProperty({
  __proto__: null,
  createFlatProxy: Zt,
  createRecursiveProxy: Dt,
  getCauseFromUnknown: Ut,
  getErrorShape: Fn,
  transformTRPCResponse: Jn
}, Symbol.toStringTag, { value: "Module" }));
function ar(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function Qn(t) {
  return t instanceof jr || /**
  * @deprecated
  * Delete in next major
  */
  t instanceof Error && t.name === "TRPCClientError";
}
function Kn(t) {
  return ar(t) && ar(t.error) && typeof t.error.code == "number" && typeof t.error.message == "string";
}
var jr = class ke extends Error {
  static from(e, r = {}) {
    const n = e;
    return Qn(n) ? (r.meta && (n.meta = {
      ...n.meta,
      ...r.meta
    }), n) : Kn(n) ? new ke(n.error.message, {
      ...r,
      result: n
    }) : n instanceof Error ? new ke(n.message, {
      ...r,
      cause: Ut(n)
    }) : new ke("Unknown error", {
      ...r,
      cause: n
    });
  }
  constructor(e, r) {
    const n = r?.cause;
    super(e, {
      cause: n
    }), this.meta = r?.meta, this.cause = n, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, ke.prototype);
  }
};
function es(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var ht = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function ts(t) {
  const { direction: e, type: r, path: n, id: s, input: a } = t, i = [], o = [];
  if (t.colorMode === "ansi") {
    const [h, y] = ht.ansi.regular[r], [k2, T] = ht.ansi.bold[r], N = "\x1B[0m";
    return i.push(e === "up" ? h : y, e === "up" ? ">>" : "<<", r, e === "up" ? k2 : T, `#${s}`, n, N), e === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: i,
      args: o
    };
  }
  const [c, u] = ht.css[r], d = `
    background-color: #${e === "up" ? c : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return i.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(d, `${d}; font-weight: bold;`, `${d}; font-weight: normal;`), e === "up" ? o.push({
    input: a,
    context: t.context
  }) : o.push({
    input: a,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: i,
    args: o
  };
}
var rs = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = es(n) ? Object.fromEntries(n) : n, { parts: a, args: i } = ts({
    ...r,
    colorMode: e,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    a.join(" ")
  ].concat(i));
};
function ns(t = {}) {
  const { enabled: e = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = rs({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: a }) => rt((i) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const d = Date.now() - o;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: d,
        result: u
      });
    }
    return a(s).pipe(Er({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(i);
  });
}
var ss = class {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return Or({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(Tr());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = Rr(r);
    return new Promise((i, o) => {
      e.signal?.addEventListener("abort", s), n.then((c) => {
        i(c.result.data);
      }).catch((c) => {
        o(jr.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n?.context
    }).subscribe({
      next(a) {
        a.result.type === "started" ? n.onStarted?.() : a.result.type === "stopped" ? n.onStopped?.() : n.onData?.(a.result.data);
      },
      error(a) {
        n.onError?.(a);
      },
      complete() {
        n.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
};
var as = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var is = (t) => as[t];
function os(t) {
  return Zt((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Dt(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], a = is(s.pop()), i = s.join(".");
    return t[a](i, ...n);
  }));
}
function cs(t) {
  const e = new ss(t);
  return os(e);
}
function us(t) {
  if (t instanceof me || t instanceof Error && t.name === "TRPCError")
    return t;
  const e = new me({
    code: "INTERNAL_SERVER_ERROR",
    cause: t
  });
  return t instanceof Error && t.stack && (e.stack = t.stack), e;
}
var me = class extends Error {
  constructor(e) {
    const r = Ut(e.cause), n = e.message ?? r?.message ?? e.code;
    super(n, {
      cause: r
    }), this.code = e.code, this.name = "TRPCError", this.cause || (this.cause = r);
  }
};
function ls(t) {
  return "input" in t ? t : {
    input: t,
    output: t
  };
}
var Re = {
  _default: true,
  input: {
    serialize: (t) => t,
    deserialize: (t) => t
  },
  output: {
    serialize: (t) => t,
    deserialize: (t) => t
  }
};
var Oe = ({ shape: t }) => t;
function ds(t) {
  return Object.assign(/* @__PURE__ */ Object.create(null), t);
}
var fs = [
  "query",
  "mutation",
  "subscription"
];
function ps(t) {
  return "router" in t._def;
}
var hs = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: Oe,
  transformer: Re
};
var ms = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function Ar(t) {
  return function(r) {
    const n = new Set(Object.keys(r).filter((c) => ms.includes(c)));
    if (n.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n).join(", "));
    const s = ds({});
    function a(c, u = "") {
      for (const [d, h] of Object.entries(c ?? {})) {
        const y = `${u}${d}`;
        if (ps(h)) {
          a(h._def.procedures, `${y}.`);
          continue;
        }
        if (s[y])
          throw new Error(`Duplicate key: ${y}`);
        s[y] = h;
      }
    }
    a(r);
    const i = {
      _config: t,
      router: true,
      procedures: s,
      ...hs,
      record: r,
      queries: Object.entries(s).filter((c) => c[1]._def.query).reduce((c, [u, d]) => ({
        ...c,
        [u]: d
      }), {}),
      mutations: Object.entries(s).filter((c) => c[1]._def.mutation).reduce((c, [u, d]) => ({
        ...c,
        [u]: d
      }), {}),
      subscriptions: Object.entries(s).filter((c) => c[1]._def.subscription).reduce((c, [u, d]) => ({
        ...c,
        [u]: d
      }), {})
    }, o = {
      ...r,
      _def: i,
      createCaller(c) {
        return Lr()(o)(c);
      },
      getErrorShape(c) {
        const { path: u, error: d } = c, { code: h } = c.error, y = {
          message: d.message,
          code: nt[h],
          data: {
            code: h,
            httpStatus: Pr(d)
          }
        };
        return t.isDev && typeof c.error.stack == "string" && (y.data.stack = c.error.stack), typeof u == "string" && (y.data.path = u), this._def._config.errorFormatter({
          ...c,
          shape: y
        });
      }
    };
    return o;
  };
}
function ys(t) {
  const { type: e, path: r } = t;
  if (!(r in t.procedures) || !t.procedures[r]?._def[e])
    throw new me({
      code: "NOT_FOUND",
      message: `No "${e}"-procedure on path "${r}"`
    });
  const n = t.procedures[r];
  return n(t);
}
function Lr() {
  return function(e) {
    const r = e._def;
    return function(s) {
      return Dt(({ path: i, args: o }) => {
        if (i.length === 1 && fs.includes(i[0]))
          return ys({
            procedures: r.procedures,
            path: o[0],
            rawInput: o[1],
            ctx: s,
            type: i[0]
          });
        const c = i.join("."), u = r.procedures[c];
        let d = "query";
        return u._def.mutation ? d = "mutation" : u._def.subscription && (d = "subscription"), u({
          path: c,
          rawInput: o[0],
          ctx: s,
          type: d
        });
      });
    };
  };
}
var ir = typeof window > "u" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
function or(t) {
  const e = t;
  if (typeof e == "function")
    return e;
  if (typeof e.parseAsync == "function")
    return e.parseAsync.bind(e);
  if (typeof e.parse == "function")
    return e.parse.bind(e);
  if (typeof e.validateSync == "function")
    return e.validateSync.bind(e);
  if (typeof e.create == "function")
    return e.create.bind(e);
  if (typeof e.assert == "function")
    return (r) => (e.assert(r), r);
  throw new Error("Could not find a validator fn");
}
function $r(t, ...e) {
  const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
  for (const n of e)
    for (const s in n) {
      if (s in r && r[s] !== n[s])
        throw new Error(`Duplicate key ${s}`);
      r[s] = n[s];
    }
  return r;
}
function gs() {
  function t(r) {
    return {
      _middlewares: r,
      unstable_pipe(n) {
        const s = "_middlewares" in n ? n._middlewares : [
          n
        ];
        return t([
          ...r,
          ...s
        ]);
      }
    };
  }
  function e(r) {
    return t([
      r
    ]);
  }
  return e;
}
function cr(t) {
  return t && typeof t == "object" && !Array.isArray(t);
}
function _s(t) {
  const e = async ({ next: r, rawInput: n, input: s }) => {
    let a;
    try {
      a = await t(n);
    } catch (o) {
      throw new me({
        code: "BAD_REQUEST",
        cause: o
      });
    }
    const i = cr(s) && cr(a) ? {
      ...s,
      ...a
    } : a;
    return r({
      input: i
    });
  };
  return e._type = "input", e;
}
function vs(t) {
  const e = async ({ next: r }) => {
    const n = await r();
    if (!n.ok)
      return n;
    try {
      const s = await t(n.data);
      return {
        ...n,
        data: s
      };
    } catch (s) {
      throw new me({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: s
      });
    }
  };
  return e._type = "output", e;
}
var Mr = "middlewareMarker";
function de(t, e) {
  const { middlewares: r = [], inputs: n, meta: s, ...a } = e;
  return Dr({
    ...$r(t, a),
    inputs: [
      ...t.inputs,
      ...n ?? []
    ],
    middlewares: [
      ...t.middlewares,
      ...r
    ],
    meta: t.meta && s ? {
      ...t.meta,
      ...s
    } : s ?? t.meta
  });
}
function Dr(t = {}) {
  const e = {
    inputs: [],
    middlewares: [],
    ...t
  };
  return {
    _def: e,
    input(r) {
      const n = or(r);
      return de(e, {
        inputs: [
          r
        ],
        middlewares: [
          _s(n)
        ]
      });
    },
    output(r) {
      const n = or(r);
      return de(e, {
        output: r,
        middlewares: [
          vs(n)
        ]
      });
    },
    meta(r) {
      return de(e, {
        meta: r
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(r) {
      return de(e, r._def);
    },
    use(r) {
      const n = "_middlewares" in r ? r._middlewares : [
        r
      ];
      return de(e, {
        middlewares: n
      });
    },
    query(r) {
      return mt({
        ...e,
        query: true
      }, r);
    },
    mutation(r) {
      return mt({
        ...e,
        mutation: true
      }, r);
    },
    subscription(r) {
      return mt({
        ...e,
        subscription: true
      }, r);
    }
  };
}
function mt(t, e) {
  const r = de(t, {
    resolver: e,
    middlewares: [
      async function(s) {
        const a = await e(s);
        return {
          marker: Mr,
          ok: true,
          data: a,
          ctx: s.ctx
        };
      }
    ]
  });
  return ws(r._def);
}
var bs = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls
`.trim();
function ws(t) {
  const e = async function(n) {
    if (!n || !("rawInput" in n))
      throw new Error(bs);
    const s = async (i = {
      index: 0,
      ctx: n.ctx
    }) => {
      try {
        const o = t.middlewares[i.index];
        return await o({
          ctx: i.ctx,
          type: n.type,
          path: n.path,
          rawInput: i.rawInput ?? n.rawInput,
          meta: t.meta,
          input: i.input,
          next(u) {
            const d = u;
            return s({
              index: i.index + 1,
              ctx: d && "ctx" in d ? {
                ...i.ctx,
                ...d.ctx
              } : i.ctx,
              input: d && "input" in d ? d.input : i.input,
              rawInput: d && "rawInput" in d ? d.rawInput : i.rawInput
            });
          }
        });
      } catch (o) {
        return {
          ok: false,
          error: us(o),
          marker: Mr
        };
      }
    }, a = await s();
    if (!a)
      throw new me({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!a.ok)
      throw a.error;
    return a.data;
  };
  return e._def = t, e.meta = t.meta, e;
}
function xs(...t) {
  const e = $r({}, ...t.map((a) => a._def.record)), r = t.reduce((a, i) => {
    if (i._def._config.errorFormatter && i._def._config.errorFormatter !== Oe) {
      if (a !== Oe && a !== i._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return i._def._config.errorFormatter;
    }
    return a;
  }, Oe), n = t.reduce((a, i) => {
    if (i._def._config.transformer && i._def._config.transformer !== Re) {
      if (a !== Re && a !== i._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return i._def._config.transformer;
    }
    return a;
  }, Re);
  return Ar({
    errorFormatter: r,
    transformer: n,
    isDev: t.some((a) => a._def._config.isDev),
    allowOutsideOfServer: t.some((a) => a._def._config.allowOutsideOfServer),
    isServer: t.some((a) => a._def._config.isServer),
    $types: t[0]?._def._config.$types
  })(e);
}
var Fe = class _Fe {
  context() {
    return new _Fe();
  }
  meta() {
    return new _Fe();
  }
  create(e) {
    return Ts()(e);
  }
};
var ks = new Fe();
function Ts() {
  return function(e) {
    const r = e?.errorFormatter ?? Oe, s = {
      transformer: ls(e?.transformer ?? Re),
      isDev: e?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
      allowOutsideOfServer: e?.allowOutsideOfServer ?? false,
      errorFormatter: r,
      isServer: e?.isServer ?? ir,
      /**
      * @internal
      */
      $types: Zt((a) => {
        throw new Error(`Tried to access "$types.${a}" which is not available at runtime`);
      })
    };
    if (!(e?.isServer ?? ir) && e?.allowOutsideOfServer !== true)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: s,
      /**
      * Builder object for creating procedures
      * @see https://trpc.io/docs/server/procedures
      */
      procedure: Dr({
        meta: e?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      * @see https://trpc.io/docs/server/middlewares
      */
      middleware: gs(),
      /**
      * Create a router
      * @see https://trpc.io/docs/server/routers
      */
      router: Ar(s),
      /**
      * Merge Routers
      * @see https://trpc.io/docs/server/merging-routers
      */
      mergeRouters: xs,
      /**
      * Create a server-side caller for a router
      * @see https://trpc.io/docs/server/server-side-calls
      */
      createCallerFactory: Lr()
    };
  };
}
var Ct = {};
var st = {};
var ve = {};
var O = {};
var be = q(zn);
var Wt = {};
var Zr = be;
function Ur(t) {
  return Zr.observable((e) => {
    function r(s = 0, a = t.op) {
      const i = t.links[s];
      if (!i)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return i({
        op: a,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function ur(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function Es(t) {
  return (e) => {
    const r = ur(t.true).map((s) => s(e)), n = ur(t.false).map((s) => s(e));
    return (s) => Zr.observable((a) => {
      const i = t.condition(s.op) ? r : n;
      return Ur({
        op: s.op,
        links: i
      }).subscribe(a);
    });
  };
}
Wt.createChain = Ur;
Wt.splitLink = Es;
var we = {};
var Wr = q(Xn);
var xe = {};
function Rt(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function Cs(t, e) {
  if ("error" in t) {
    const n = e.transformer.deserialize(t.error);
    return {
      ok: false,
      error: {
        ...t,
        error: n
      }
    };
  }
  return {
    ok: true,
    result: {
      ...t.result,
      ...(!t.result.type || t.result.type === "data") && {
        type: "data",
        data: e.transformer.deserialize(t.result.data)
      }
    }
  };
}
var yt = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function Rs(t, e) {
  let r;
  try {
    r = Cs(t, e);
  } catch {
    throw new yt();
  }
  if (!r.ok && (!Rt(r.error.error) || typeof r.error.error.code != "number"))
    throw new yt();
  if (r.ok && !Rt(r.result))
    throw new yt();
  return r;
}
xe.isObject = Rt;
xe.transformResult = Rs;
var Os = Wr;
var lr = xe;
function Ss(t) {
  return t instanceof qr || /**
  * @deprecated
  * Delete in next major
  */
  t instanceof Error && t.name === "TRPCClientError";
}
function Ps(t) {
  return lr.isObject(t) && lr.isObject(t.error) && typeof t.error.code == "number" && typeof t.error.message == "string";
}
var qr = class Te extends Error {
  static from(e, r = {}) {
    const n = e;
    return Ss(n) ? (r.meta && (n.meta = {
      ...n.meta,
      ...r.meta
    }), n) : Ps(n) ? new Te(n.error.message, {
      ...r,
      result: n
    }) : n instanceof Error ? new Te(n.message, {
      ...r,
      cause: Os.getCauseFromUnknown(n)
    }) : new Te("Unknown error", {
      ...r,
      cause: n
    });
  }
  constructor(e, r) {
    const n = r?.cause;
    super(e, {
      cause: n
    }), this.meta = r?.meta, this.cause = n, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Te.prototype);
  }
};
we.TRPCClientError = qr;
var H = {};
var Ns = we;
var dr = (t) => typeof t == "function";
function zr(t) {
  if (t)
    return t;
  if (typeof window < "u" && dr(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && dr(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function Is(t) {
  return t || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function js(t) {
  return {
    url: t.url.toString().replace(/\/$/, ""),
    fetch: t.fetch,
    AbortController: Is(t.AbortController)
  };
}
function As(t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    e[r] = n;
  }
  return e;
}
var Ls = {
  query: "GET",
  mutation: "POST"
};
function Br(t) {
  return "input" in t ? t.runtime.transformer.serialize(t.input) : As(t.inputs.map((e) => t.runtime.transformer.serialize(e)));
}
var Vr = (t) => {
  let e = t.url + "/" + t.path;
  const r = [];
  if ("inputs" in t && r.push("batch=1"), t.type === "query") {
    const n = Br(t);
    n !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n))}`);
  }
  return r.length && (e += "?" + r.join("&")), e;
};
var Hr = (t) => {
  if (t.type === "query")
    return;
  const e = Br(t);
  return e !== void 0 ? JSON.stringify(e) : void 0;
};
var $s = (t) => Jr({
  ...t,
  contentTypeHeader: "application/json",
  getUrl: Vr,
  getBody: Hr
});
async function Fr(t, e) {
  const r = t.getUrl(t), n = t.getBody(t), { type: s } = t, a = await t.headers();
  if (s === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const i = {
    ...t.contentTypeHeader ? {
      "content-type": t.contentTypeHeader
    } : {},
    ...t.batchModeHeader ? {
      "trpc-batch-mode": t.batchModeHeader
    } : {},
    ...a
  };
  return zr(t.fetch)(r, {
    method: Ls[s],
    signal: e?.signal,
    body: n,
    headers: i
  });
}
function Jr(t) {
  const e = t.AbortController ? new t.AbortController() : null, r = {};
  let n = false;
  return {
    promise: new Promise((i, o) => {
      Fr(t, e).then((c) => (r.response = c, n = true, c.json())).then((c) => {
        r.responseJSON = c, i({
          json: c,
          meta: r
        });
      }).catch((c) => {
        n = true, o(Ns.TRPCClientError.from(c, {
          meta: r
        }));
      });
    }),
    cancel: () => {
      n || e?.abort();
    }
  };
}
H.fetchHTTPResponse = Fr;
H.getBody = Hr;
H.getFetch = zr;
H.getUrl = Vr;
H.httpRequest = Jr;
H.jsonHttpRequester = $s;
H.resolveHTTPLinkOptions = js;
var qt = {};
var Ms = be;
var Ds = xe;
var fr = we;
var Ot = H;
var gt = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function _t(t) {
  let e = null, r = null;
  const n = () => {
    clearTimeout(r), r = null, e = null;
  };
  function s(o) {
    const c = [
      []
    ];
    let u = 0;
    for (; ; ) {
      const d = o[u];
      if (!d)
        break;
      const h = c[c.length - 1];
      if (d.aborted) {
        d.reject?.(new Error("Aborted")), u++;
        continue;
      }
      if (t.validate(h.concat(d).map((k2) => k2.key))) {
        h.push(d), u++;
        continue;
      }
      if (h.length === 0) {
        d.reject?.(new Error("Input is too big for a single dispatch")), u++;
        continue;
      }
      c.push([]);
    }
    return c;
  }
  function a() {
    const o = s(e);
    n();
    for (const c of o) {
      if (!c.length)
        continue;
      const u = {
        items: c,
        cancel: gt
      };
      for (const k2 of c)
        k2.batch = u;
      const d = (k2, T) => {
        const N = u.items[k2];
        N.resolve?.(T), N.batch = null, N.reject = null, N.resolve = null;
      }, { promise: h, cancel: y } = t.fetch(u.items.map((k2) => k2.key), d);
      u.cancel = y, h.then((k2) => {
        for (let T = 0; T < k2.length; T++) {
          const N = k2[T];
          d(T, N);
        }
        for (const T of u.items)
          T.reject?.(new Error("Missing result")), T.batch = null;
      }).catch((k2) => {
        for (const T of u.items)
          T.reject?.(k2), T.batch = null;
      });
    }
  }
  function i(o) {
    const c = {
      aborted: false,
      key: o,
      batch: null,
      resolve: gt,
      reject: gt
    }, u = new Promise((h, y) => {
      c.reject = y, c.resolve = h, e || (e = []), e.push(c);
    });
    return r || (r = setTimeout(a)), {
      promise: u,
      cancel: () => {
        c.aborted = true, c.batch?.items.every((h) => h.aborted) && (c.batch.cancel(), c.batch = null);
      }
    };
  }
  return {
    load: i
  };
}
function Gr(t) {
  return function(r) {
    const n = Ot.resolveHTTPLinkOptions(r), s = r.maxURLLength ?? 1 / 0;
    return (a) => {
      const i = (h) => {
        const y = (T) => {
          if (s === 1 / 0)
            return true;
          const N = T.map((F2) => F2.path).join(","), oe = T.map((F2) => F2.input);
          return Ot.getUrl({
            ...n,
            runtime: a,
            type: h,
            path: N,
            inputs: oe
          }).length <= s;
        }, k2 = t({
          ...n,
          runtime: a,
          type: h,
          opts: r
        });
        return {
          validate: y,
          fetch: k2
        };
      }, o = _t(i("query")), c = _t(i("mutation")), u = _t(i("subscription")), d = {
        query: o,
        subscription: u,
        mutation: c
      };
      return ({ op: h }) => Ms.observable((y) => {
        const k2 = d[h.type], { promise: T, cancel: N } = k2.load(h);
        let oe;
        return T.then(($) => {
          oe = $;
          const F2 = Ds.transformResult($.json, a);
          if (!F2.ok) {
            y.error(fr.TRPCClientError.from(F2.error, {
              meta: $.meta
            }));
            return;
          }
          y.next({
            context: $.meta,
            result: F2.result
          }), y.complete();
        }).catch(($) => {
          y.error(fr.TRPCClientError.from($, {
            meta: oe?.meta
          }));
        }), () => {
          N();
        };
      });
    };
  };
}
var Zs = (t) => (e) => {
  const r = e.map((i) => i.path).join(","), n = e.map((i) => i.input), { promise: s, cancel: a } = Ot.jsonHttpRequester({
    ...t,
    path: r,
    inputs: n,
    headers() {
      return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
        opList: e
      }) : t.opts.headers : {};
    }
  });
  return {
    promise: s.then((i) => (Array.isArray(i.json) ? i.json : e.map(() => i.json)).map((u) => ({
      meta: i.meta,
      json: u
    }))),
    cancel: a
  };
};
var Us = Gr(Zs);
qt.createHTTPBatchLink = Gr;
qt.httpBatchLink = Us;
var at = {};
Object.defineProperty(at, "__esModule", { value: true });
var Ws = be;
var qs = xe;
var pr = we;
var Yr = H;
function Xr(t) {
  return (e) => {
    const r = Yr.resolveHTTPLinkOptions(e);
    return (n) => ({ op: s }) => Ws.observable((a) => {
      const { path: i, input: o, type: c } = s, { promise: u, cancel: d } = t.requester({
        ...r,
        runtime: n,
        type: c,
        path: i,
        input: o,
        headers() {
          return e.headers ? typeof e.headers == "function" ? e.headers({
            op: s
          }) : e.headers : {};
        }
      });
      let h;
      return u.then((y) => {
        h = y.meta;
        const k2 = qs.transformResult(y.json, n);
        if (!k2.ok) {
          a.error(pr.TRPCClientError.from(k2.error, {
            meta: h
          }));
          return;
        }
        a.next({
          context: y.meta,
          result: k2.result
        }), a.complete();
      }).catch((y) => {
        a.error(pr.TRPCClientError.from(y, {
          meta: h
        }));
      }), () => {
        d();
      };
    });
  };
}
var zs = Xr({
  requester: Yr.jsonHttpRequester
});
at.httpLink = zs;
at.httpLinkFactory = Xr;
var zt = {};
Object.defineProperty(zt, "__esModule", { value: true });
var hr = be;
function Bs(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var vt = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function Vs(t) {
  const { direction: e, type: r, path: n, id: s, input: a } = t, i = [], o = [];
  if (t.colorMode === "ansi") {
    const [h, y] = vt.ansi.regular[r], [k2, T] = vt.ansi.bold[r], N = "\x1B[0m";
    return i.push(e === "up" ? h : y, e === "up" ? ">>" : "<<", r, e === "up" ? k2 : T, `#${s}`, n, N), e === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: i,
      args: o
    };
  }
  const [c, u] = vt.css[r], d = `
    background-color: #${e === "up" ? c : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return i.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(d, `${d}; font-weight: bold;`, `${d}; font-weight: normal;`), e === "up" ? o.push({
    input: a,
    context: t.context
  }) : o.push({
    input: a,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: i,
    args: o
  };
}
var Hs = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = Bs(n) ? Object.fromEntries(n) : n, { parts: a, args: i } = Vs({
    ...r,
    colorMode: e,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    a.join(" ")
  ].concat(i));
};
function Fs(t = {}) {
  const { enabled: e = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = Hs({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: a }) => hr.observable((i) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const d = Date.now() - o;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: d,
        result: u
      });
    }
    return a(s).pipe(hr.tap({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(i);
  });
}
zt.loggerLink = Fs;
var it = {};
Object.defineProperty(it, "__esModule", { value: true });
var Js = be;
var Gs = xe;
var Qr = we;
var Ys = (t) => t === 0 ? 0 : Math.min(1e3 * 2 ** t, 3e4);
function Xs(t) {
  const { url: e, WebSocket: r = WebSocket, retryDelayMs: n = Ys, onOpen: s, onClose: a } = t;
  if (!r)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let i = [];
  const o = /* @__PURE__ */ Object.create(null);
  let c = 0, u = null, d = null, h = Xt(), y = "connecting";
  function k2() {
    y !== "open" || u || (u = setTimeout(() => {
      u = null, i.length === 1 ? h.send(JSON.stringify(i.pop())) : h.send(JSON.stringify(i)), i = [];
    }));
  }
  function T() {
    if (d !== null || y === "closed")
      return;
    const R2 = n(c++);
    oe(R2);
  }
  function N() {
    y = "connecting";
    const R2 = h;
    h = Xt(), $(R2);
  }
  function oe(R2) {
    d || (y = "connecting", d = setTimeout(N, R2));
  }
  function $(R2) {
    Object.values(o).some((ce) => ce.ws === R2) || R2.close();
  }
  function F2() {
    Object.values(o).forEach((R2) => {
      R2.type === "subscription" && R2.callbacks.complete();
    });
  }
  function Yt(R2) {
    i.some((S3) => S3.id === R2.op.id) || Qt(R2.op, R2.callbacks);
  }
  function Xt() {
    const R2 = typeof e == "function" ? e() : e, S3 = new r(R2);
    clearTimeout(d), d = null, S3.addEventListener("open", () => {
      S3 === h && (c = 0, y = "open", s?.(), k2());
    }), S3.addEventListener("error", () => {
      S3 === h && T();
    });
    const ce = (A2) => {
      if (A2.method === "reconnect" && S3 === h) {
        y === "open" && a?.(), N();
        for (const E of Object.values(o))
          E.type === "subscription" && Yt(E);
      }
    }, ft = (A2) => {
      const E = A2.id !== null && o[A2.id];
      if (E) {
        if (E.callbacks.next?.(A2), E.ws !== h && S3 === h) {
          const J = E.ws;
          E.ws = h, $(J);
        }
        "result" in A2 && A2.result.type === "stopped" && S3 === h && E.callbacks.complete();
      }
    };
    return S3.addEventListener("message", ({ data: A2 }) => {
      const E = JSON.parse(A2);
      "method" in E ? ce(E) : ft(E), (S3 !== h || y === "closed") && $(S3);
    }), S3.addEventListener("close", ({ code: A2 }) => {
      y === "open" && a?.({
        code: A2
      }), h === S3 && T();
      for (const [E, J] of Object.entries(o))
        if (J.ws === S3) {
          if (y === "closed") {
            delete o[E], J.callbacks.complete?.();
            continue;
          }
          J.type === "subscription" ? Yt(J) : (delete o[E], J.callbacks.error?.(Qr.TRPCClientError.from(new Bt("WebSocket closed prematurely"))));
        }
    }), S3;
  }
  function Qt(R2, S3) {
    const { type: ce, input: ft, path: A2, id: E } = R2, J = {
      id: E,
      method: ce,
      params: {
        input: ft,
        path: A2
      }
    };
    return o[E] = {
      ws: h,
      type: ce,
      callbacks: S3,
      op: R2
    }, i.push(J), k2(), () => {
      const kn = o[E]?.callbacks;
      delete o[E], i = i.filter((Tn) => Tn.id !== E), kn?.complete?.(), h.readyState === r.OPEN && R2.type === "subscription" && (i.push({
        id: E,
        method: "subscription.stop"
      }), k2());
    };
  }
  return {
    close: () => {
      y = "closed", a?.(), F2(), $(h), clearTimeout(d), d = null;
    },
    request: Qt,
    getConnection() {
      return h;
    }
  };
}
var Bt = class _Bt extends Error {
  constructor(e) {
    super(e), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, _Bt.prototype);
  }
};
function Qs(t) {
  return (e) => {
    const { client: r } = t;
    return ({ op: n }) => Js.observable((s) => {
      const { type: a, path: i, id: o, context: c } = n, u = e.transformer.serialize(n.input), d = r.request({
        type: a,
        path: i,
        input: u,
        id: o,
        context: c
      }, {
        error(h) {
          s.error(h), d();
        },
        complete() {
          s.complete();
        },
        next(h) {
          const y = Gs.transformResult(h, e);
          if (!y.ok) {
            s.error(Qr.TRPCClientError.from(y.error));
            return;
          }
          s.next({
            result: y.result
          }), n.type !== "subscription" && (d(), s.complete());
        }
      });
      return () => {
        d();
      };
    });
  };
}
it.createWSClient = Xs;
it.wsLink = Qs;
Object.defineProperty(O, "__esModule", { value: true });
var mr = be;
var Kr = Wt;
var en = we;
var yr = Wr;
var Se = H;
var tn = qt;
var Vt = at;
var Ks = zt;
var rn = it;
var ot = class {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return Kr.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(mr.share());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = mr.observableToPromise(r);
    return new Promise((i, o) => {
      e.signal?.addEventListener("abort", s), n.then((c) => {
        i(c.result.data);
      }).catch((c) => {
        o(en.TRPCClientError.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n?.context
    }).subscribe({
      next(a) {
        a.result.type === "started" ? n.onStarted?.() : a.result.type === "stopped" ? n.onStopped?.() : n.onData?.(a.result.data);
      },
      error(a) {
        n.onError?.(a);
      },
      complete() {
        n.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
};
function ea(t) {
  return new ot(t);
}
function ta(t) {
  return new ot(t);
}
var ra = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var nn = (t) => ra[t];
function sn(t) {
  return yr.createFlatProxy((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : yr.createRecursiveProxy(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], a = nn(s.pop()), i = s.join(".");
    return t[a](i, ...n);
  }));
}
function na(t) {
  const e = new ot(t);
  return sn(e);
}
function sa(t) {
  return t.__untypedClient;
}
function aa(t) {
  if (t)
    return t;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function ia(t) {
  const e = t.parse ?? JSON.parse, r = (n) => {
    if (t.signal?.aborted || !n || n === "}")
      return;
    const s = n.indexOf(":"), a = n.substring(2, s - 1), i = n.substring(s + 1);
    t.onSingle(Number(a), e(i));
  };
  await oa(t.readableStream, r, t.textDecoder);
}
async function oa(t, e, r) {
  let n = "";
  const s = (a) => {
    const o = r.decode(a).split(`
`);
    if (o.length === 1)
      n += o[0];
    else if (o.length > 1) {
      e(n + o[0]);
      for (let c = 1; c < o.length - 1; c++)
        e(o[c]);
      n = o[o.length - 1];
    }
  };
  "getReader" in t ? await ua(t, s) : await ca(t, s), e(n);
}
function ca(t, e) {
  return new Promise((r) => {
    t.on("data", e), t.on("end", r);
  });
}
async function ua(t, e) {
  const r = t.getReader();
  let n = await r.read();
  for (; !n.done; )
    e(n.value), n = await r.read();
}
var la = (t, e) => {
  const r = t.AbortController ? new t.AbortController() : null, n = Se.fetchHTTPResponse({
    ...t,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: Se.getUrl,
    getBody: Se.getBody
  }, r), s = () => r?.abort(), a = n.then(async (i) => {
    if (!i.body)
      throw new Error("Received response without body");
    const o = {
      response: i
    };
    return ia({
      readableStream: i.body,
      onSingle: e,
      parse: (c) => ({
        json: JSON.parse(c),
        meta: o
      }),
      signal: r?.signal,
      textDecoder: t.textDecoder
    });
  });
  return {
    cancel: s,
    promise: a
  };
};
var da = (t) => {
  const e = aa(t.opts.textDecoder);
  return (r, n) => {
    const s = r.map((c) => c.path).join(","), a = r.map((c) => c.input), { cancel: i, promise: o } = la({
      ...t,
      textDecoder: e,
      path: s,
      inputs: a,
      headers() {
        return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
          opList: r
        }) : t.opts.headers : {};
      }
    }, (c, u) => {
      n(c, u);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: o.then(() => []),
      cancel: i
    };
  };
};
var fa = tn.createHTTPBatchLink(da);
var pa = (t) => {
  if ("input" in t) {
    if (!(t.input instanceof FormData))
      throw new Error("Input is not FormData");
    return t.input;
  }
};
var ha = (t) => {
  if (t.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return Se.httpRequest({
    ...t,
    getUrl() {
      return `${t.url}/${t.path}`;
    },
    getBody: pa
  });
};
var ma = Vt.httpLinkFactory({
  requester: ha
});
O.splitLink = Kr.splitLink;
O.TRPCClientError = en.TRPCClientError;
O.getFetch = Se.getFetch;
O.httpBatchLink = tn.httpBatchLink;
O.httpLink = Vt.httpLink;
O.httpLinkFactory = Vt.httpLinkFactory;
O.loggerLink = Ks.loggerLink;
O.createWSClient = rn.createWSClient;
O.wsLink = rn.wsLink;
O.TRPCUntypedClient = ot;
O.clientCallTypeToProcedureType = nn;
O.createTRPCClient = ta;
O.createTRPCClientProxy = sn;
O.createTRPCProxyClient = na;
O.createTRPCUntypedClient = ea;
O.experimental_formDataLink = ma;
O.getUntypedClient = sa;
O.unstable_httpBatchStreamLink = fa;
var re = {};
var Ht = {};
function ya(t) {
  return t;
}
function ga(t) {
  return t.length === 0 ? ya : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function _a(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function va(t) {
  const e = {
    subscribe(r) {
      let n = null, s = false, a = false, i = false;
      function o() {
        if (n === null) {
          i = true;
          return;
        }
        a || (a = true, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          s || r.next?.(c);
        },
        error(c) {
          s || (s = true, r.error?.(c), o());
        },
        complete() {
          s || (s = true, r.complete?.(), o());
        }
      }), i && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return ga(r)(e);
    }
  };
  return e;
}
Ht.isObservable = _a;
Ht.observable = va;
Object.defineProperty(re, "__esModule", { value: true });
var an = Ht;
function ba(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function a() {
      n || (n = e.subscribe({
        next(o) {
          for (const c of s)
            c.next?.(o);
        },
        error(o) {
          for (const c of s)
            c.error?.(o);
        },
        complete() {
          for (const o of s)
            o.complete?.();
        }
      }));
    }
    function i() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), a(), {
          unsubscribe() {
            r--, i();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function wa(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(a) {
          r.next?.(t(a, n++));
        },
        error(a) {
          r.error?.(a);
        },
        complete() {
          r.complete?.();
        }
      });
    }
  });
}
function xa(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          t.next?.(n), r.next?.(n);
        },
        error(n) {
          t.error?.(n), r.error?.(n);
        },
        complete() {
          t.complete?.(), r.complete?.();
        }
      });
    }
  });
}
var Ft = class _Ft extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, _Ft.prototype);
  }
};
function ka(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let a = false;
      function i() {
        a || (a = true, s(new Ft("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          a = true, n(c), i();
        },
        error(c) {
          a = true, s(c), i();
        },
        complete() {
          a = true, i();
        }
      });
      e = i;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
re.isObservable = an.isObservable;
re.observable = an.observable;
re.map = wa;
re.observableToPromise = ka;
re.share = ba;
re.tap = xa;
var q2 = {};
Object.defineProperty(q2, "__esModule", { value: true });
q2.isTRPCRequestWithId = q2.isTRPCRequest = q2.isTRPCResponse = q2.isTRPCMessage = void 0;
function gr(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function Ta(t) {
  return t == null;
}
function on(t) {
  return !!(gr(t) && "trpc" in t && gr(t.trpc));
}
q2.isTRPCMessage = on;
function Jt(t) {
  return on(t) && "id" in t.trpc && !Ta(t.trpc.id);
}
function Ea(t) {
  return Jt(t) && ("error" in t.trpc || "result" in t.trpc);
}
q2.isTRPCResponse = Ea;
function cn(t) {
  return Jt(t) && "method" in t.trpc;
}
q2.isTRPCRequest = cn;
function Ca(t) {
  return cn(t) && Jt(t);
}
q2.isTRPCRequestWithId = Ca;
Object.defineProperty(ve, "__esModule", { value: true });
ve.createBaseLink = void 0;
var bt = O;
var Ra = re;
var Oa = q2;
var Sa = (t) => (e) => ({ op: r }) => (0, Ra.observable)((n) => {
  const s = [], { id: a, type: i, path: o } = r;
  try {
    const c = e.transformer.serialize(r.input), u = () => {
      n.error(new bt.TRPCClientError("Port disconnected prematurely"));
    };
    t.addCloseListener(u), s.push(() => t.removeCloseListener(u));
    const d = (h) => {
      if (!(0, Oa.isTRPCResponse)(h))
        return;
      const { trpc: y } = h;
      if (a === y.id) {
        if ("error" in y)
          return n.error(bt.TRPCClientError.from(y));
        n.next({
          result: Object.assign(Object.assign({}, y.result), (!y.result.type || y.result.type === "data") && {
            type: "data",
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data: e.transformer.deserialize(y.result.data)
          })
        }), (i !== "subscription" || y.result.type === "stopped") && n.complete();
      }
    };
    t.addMessageListener(d), s.push(() => t.removeMessageListener(d)), t.postMessage({
      trpc: {
        id: a,
        jsonrpc: void 0,
        method: i,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        params: { path: o, input: c }
      }
    });
  } catch (c) {
    n.error(new bt.TRPCClientError(c instanceof Error ? c.message : "Unknown error"));
  }
  return () => {
    i === "subscription" && t.postMessage({
      trpc: {
        id: a,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), s.forEach((c) => c());
  };
});
ve.createBaseLink = Sa;
Object.defineProperty(st, "__esModule", { value: true });
st.chromeLink = void 0;
var Pa = ve;
var Na = (t) => (0, Pa.createBaseLink)({
  postMessage(e) {
    t.port.postMessage(e);
  },
  addMessageListener(e) {
    t.port.onMessage.addListener(e);
  },
  removeMessageListener(e) {
    t.port.onMessage.removeListener(e);
  },
  addCloseListener(e) {
    t.port.onDisconnect.addListener(e);
  },
  removeCloseListener(e) {
    t.port.onDisconnect.removeListener(e);
  }
});
st.chromeLink = Na;
var ct = {};
Object.defineProperty(ct, "__esModule", { value: true });
ct.windowLink = void 0;
var Ia = ve;
var ja = (t) => {
  var e;
  const r = /* @__PURE__ */ new Map(), n = t.window, s = (e = t.postWindow) !== null && e !== void 0 ? e : n;
  return (0, Ia.createBaseLink)({
    postMessage(a) {
      s.postMessage(a, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(a) {
      const i = (o) => {
        a(o.data);
      };
      r.set(a, i), n.addEventListener("message", i);
    },
    removeMessageListener(a) {
      const i = r.get(a);
      i && n.removeEventListener("message", i);
    },
    addCloseListener(a) {
      n.addEventListener("beforeunload", a);
    },
    removeCloseListener(a) {
      n.removeEventListener("beforeunload", a);
    }
  });
};
ct.windowLink = ja;
var ut = {};
var lt = {};
Object.defineProperty(lt, "__esModule", { value: true });
lt.TRPC_BROWSER_LOADED_EVENT = void 0;
lt.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(ut, "__esModule", { value: true });
ut.popupLink = void 0;
var Aa = lt;
var La = ve;
var $a = (t) => {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
  let n = null;
  async function s(a) {
    if (!n || n.closed) {
      n = t.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((i) => {
          var o;
          try {
            (o = n?.addEventListener) === null || o === void 0 || o.call(n, "load", i);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((i) => {
          a.addEventListener("message", (o) => {
            o.data === Aa.TRPC_BROWSER_LOADED_EVENT && i();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((i) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(i, 15e3);
        })
      ]);
      try {
        if (!n.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        n.addEventListener("beforeunload", () => {
          n = null;
        });
      } catch {
        const o = setInterval(() => {
          n && n.closed && (n = null, r.forEach((c) => {
            c();
          }), clearInterval(o));
        }, 1e3);
      }
    }
    return n;
  }
  return (0, La.createBaseLink)({
    async postMessage(a) {
      return (await s(t.listenWindow)).postMessage(a, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(a) {
      const i = (o) => {
        a(o.data);
      };
      e.set(a, i), t.listenWindow.addEventListener("message", i);
    },
    removeMessageListener(a) {
      const i = e.get(a);
      i && t.listenWindow.removeEventListener("message", i);
    },
    addCloseListener(a) {
      t.listenWindow.addEventListener("beforeunload", a), r.add(a);
    },
    removeCloseListener(a) {
      t.listenWindow.removeEventListener("beforeunload", a), r.delete(a);
    }
  });
};
ut.popupLink = $a;
(function(t) {
  var e = W && W.__createBinding || (Object.create ? function(n, s, a, i) {
    i === void 0 && (i = a);
    var o = Object.getOwnPropertyDescriptor(s, a);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return s[a];
    } }), Object.defineProperty(n, i, o);
  } : function(n, s, a, i) {
    i === void 0 && (i = a), n[i] = s[a];
  }), r = W && W.__exportStar || function(n, s) {
    for (var a in n)
      a !== "default" && !Object.prototype.hasOwnProperty.call(s, a) && e(s, n, a);
  };
  Object.defineProperty(t, "__esModule", { value: true }), r(st, t), r(ct, t), r(ut, t);
})(Ct);
var x;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (s) => {
    const a = {};
    for (const i of s)
      a[i] = i;
    return a;
  }, t.getValidEnumValues = (s) => {
    const a = t.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), i = {};
    for (const o of a)
      i[o] = s[o];
    return t.objectValues(i);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(a) {
    return s[a];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const a = [];
    for (const i in s)
      Object.prototype.hasOwnProperty.call(s, i) && a.push(i);
    return a;
  }, t.find = (s, a) => {
    for (const i of s)
      if (a(i))
        return i;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n(s, a = " | ") {
    return s.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a;
})(x || (x = {}));
var St;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(St || (St = {}));
var m = x.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var X = (t) => {
  switch (typeof t) {
    case "undefined":
      return m.undefined;
    case "string":
      return m.string;
    case "number":
      return isNaN(t) ? m.nan : m.number;
    case "boolean":
      return m.boolean;
    case "function":
      return m.function;
    case "bigint":
      return m.bigint;
    case "symbol":
      return m.symbol;
    case "object":
      return Array.isArray(t) ? m.array : t === null ? m.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? m.promise : typeof Map < "u" && t instanceof Map ? m.map : typeof Set < "u" && t instanceof Set ? m.set : typeof Date < "u" && t instanceof Date ? m.date : m.object;
    default:
      return m.unknown;
  }
};
var f = x.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var Ma = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
var L = class _L extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(a) {
      return a.message;
    }, n = { _errors: [] }, s = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(s);
        else if (i.code === "invalid_return_type")
          s(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          s(i.argumentsError);
        else if (i.path.length === 0)
          n._errors.push(r(i));
        else {
          let o = n, c = 0;
          for (; c < i.path.length; ) {
            const u = i.path[c];
            c === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), n;
  }
  static assert(e) {
    if (!(e instanceof _L))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, x.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
L.create = (t) => new L(t);
var ye = (t, e) => {
  let r;
  switch (t.code) {
    case f.invalid_type:
      t.received === m.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case f.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, x.jsonStringifyReplacer)}`;
      break;
    case f.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${x.joinValues(t.keys, ", ")}`;
      break;
    case f.invalid_union:
      r = "Invalid input";
      break;
    case f.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${x.joinValues(t.options)}`;
      break;
    case f.invalid_enum_value:
      r = `Invalid enum value. Expected ${x.joinValues(t.options)}, received '${t.received}'`;
      break;
    case f.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case f.invalid_return_type:
      r = "Invalid function return type";
      break;
    case f.invalid_date:
      r = "Invalid date";
      break;
    case f.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : x.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case f.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case f.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case f.custom:
      r = "Invalid input";
      break;
    case f.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case f.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case f.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, x.assertNever(t);
  }
  return { message: r };
};
var un = ye;
function Da(t) {
  un = t;
}
function Je() {
  return un;
}
var Ge = (t) => {
  const { data: e, path: r, errorMaps: n, issueData: s } = t, a = [...r, ...s.path || []], i = {
    ...s,
    path: a
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: a,
      message: s.message
    };
  let o = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(i, { data: e, defaultError: o }).message;
  return {
    ...s,
    path: a,
    message: o
  };
};
var Za = [];
function p(t, e) {
  const r = Je(), n = Ge({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      r,
      r === ye ? void 0 : ye
      // then global default map
    ].filter((s) => !!s)
  });
  t.common.issues.push(n);
}
var I = class _I {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const s of r) {
      if (s.status === "aborted")
        return v;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const s of r) {
      const a = await s.key, i = await s.value;
      n.push({
        key: a,
        value: i
      });
    }
    return _I.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const s of r) {
      const { key: a, value: i } = s;
      if (a.status === "aborted" || i.status === "aborted")
        return v;
      a.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), a.value !== "__proto__" && (typeof i.value < "u" || s.alwaysSet) && (n[a.value] = i.value);
    }
    return { status: e.value, value: n };
  }
};
var v = Object.freeze({
  status: "aborted"
});
var pe = (t) => ({ status: "dirty", value: t });
var j = (t) => ({ status: "valid", value: t });
var Pt = (t) => t.status === "aborted";
var Nt = (t) => t.status === "dirty";
var Pe = (t) => t.status === "valid";
var Ne = (t) => typeof Promise < "u" && t instanceof Promise;
function Ye(t, e, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}
function ln(t, e, r, n, s) {
  if (n === "m")
    throw new TypeError("Private method is not writable");
  if (n === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !s : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? s.call(t, r) : s ? s.value = r : e.set(t, r), r;
}
var g;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(g || (g = {}));
var Ee;
var Ce;
var B = class {
  constructor(e, r, n, s) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var _r = (t, e) => {
  if (Pe(e))
    return { success: true, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const r = new L(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function b(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n, description: s } = t;
  if (e && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (i, o) => {
    var c, u;
    const { message: d } = t;
    return i.code === "invalid_enum_value" ? { message: d ?? o.defaultError } : typeof o.data > "u" ? { message: (c = d ?? n) !== null && c !== void 0 ? c : o.defaultError } : i.code !== "invalid_type" ? { message: o.defaultError } : { message: (u = d ?? r) !== null && u !== void 0 ? u : o.defaultError };
  }, description: s };
}
var w = class {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return X(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: X(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new I(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: X(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (Ne(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const s = {
      common: {
        issues: [],
        async: (n = r?.async) !== null && n !== void 0 ? n : false,
        contextualErrorMap: r?.errorMap
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: X(e)
    }, a = this._parseSync({ data: e, path: s.path, parent: s });
    return _r(s, a);
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r?.errorMap,
        async: true
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: X(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), a = await (Ne(s) ? s : Promise.resolve(s));
    return _r(n, a);
  }
  refine(e, r) {
    const n = (s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r;
    return this._refinement((s, a) => {
      const i = e(s), o = () => a.addIssue({
        code: f.custom,
        ...n(s)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((c) => c ? true : (o(), false)) : i ? true : (o(), false);
    });
  }
  refinement(e, r) {
    return this._refinement((n, s) => e(n) ? true : (s.addIssue(typeof r == "function" ? r(n, s) : r), false));
  }
  _refinement(e) {
    return new W2({
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return z.create(this, this._def);
  }
  nullable() {
    return te.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return U2.create(this, this._def);
  }
  promise() {
    return _e.create(this, this._def);
  }
  or(e) {
    return Le.create([this, e], this._def);
  }
  and(e) {
    return $e.create(this, e, this._def);
  }
  transform(e) {
    return new W2({
      ...b(this._def),
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new We({
      ...b(this._def),
      innerType: this,
      defaultValue: r,
      typeName: _.ZodDefault
    });
  }
  brand() {
    return new Gt({
      typeName: _.ZodBranded,
      type: this,
      ...b(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new qe({
      ...b(this._def),
      innerType: this,
      catchValue: r,
      typeName: _.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Be.create(this, e);
  }
  readonly() {
    return ze.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var Ua = /^c[^\s-]{8,}$/i;
var Wa = /^[0-9a-z]+$/;
var qa = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var za = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var Ba = /^[a-z0-9_-]{21}$/i;
var Va = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var Ha = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var Fa = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var wt;
var Ja = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var Ga = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var Ya = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dn = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var Xa = new RegExp(`^${dn}$`);
function fn(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function Qa(t) {
  return new RegExp(`^${fn(t)}$`);
}
function pn(t) {
  let e = `${dn}T${fn(t)}`;
  const r = [];
  return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, new RegExp(`^${e}$`);
}
function Ka(t, e) {
  return !!((e === "v4" || !e) && Ja.test(t) || (e === "v6" || !e) && Ga.test(t));
}
var Z = class _Z extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== m.string) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f.invalid_type,
        expected: m.string,
        received: a.parsedType
      }), v;
    }
    const n = new I();
    let s;
    for (const a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value && (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.too_small,
          minimum: a.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: a.message
        }), n.dirty());
      else if (a.kind === "max")
        e.data.length > a.value && (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.too_big,
          maximum: a.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: a.message
        }), n.dirty());
      else if (a.kind === "length") {
        const i = e.data.length > a.value, o = e.data.length < a.value;
        (i || o) && (s = this._getOrReturnCtx(e, s), i ? p(s, {
          code: f.too_big,
          maximum: a.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: a.message
        }) : o && p(s, {
          code: f.too_small,
          minimum: a.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: a.message
        }), n.dirty());
      } else if (a.kind === "email")
        Ha.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "email",
          code: f.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "emoji")
        wt || (wt = new RegExp(Fa, "u")), wt.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "emoji",
          code: f.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "uuid")
        za.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "uuid",
          code: f.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "nanoid")
        Ba.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "nanoid",
          code: f.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid")
        Ua.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "cuid",
          code: f.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid2")
        Wa.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "cuid2",
          code: f.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "ulid")
        qa.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "ulid",
          code: f.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), p(s, {
            validation: "url",
            code: f.invalid_string,
            message: a.message
          }), n.dirty();
        }
      else
        a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "regex",
          code: f.invalid_string,
          message: a.message
        }), n.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: { includes: a.value, position: a.position },
          message: a.message
        }), n.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: { startsWith: a.value },
          message: a.message
        }), n.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: { endsWith: a.value },
          message: a.message
        }), n.dirty()) : a.kind === "datetime" ? pn(a).test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: "datetime",
          message: a.message
        }), n.dirty()) : a.kind === "date" ? Xa.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: "date",
          message: a.message
        }), n.dirty()) : a.kind === "time" ? Qa(a).test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: "time",
          message: a.message
        }), n.dirty()) : a.kind === "duration" ? Va.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "duration",
          code: f.invalid_string,
          message: a.message
        }), n.dirty()) : a.kind === "ip" ? Ka(e.data, a.version) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "ip",
          code: f.invalid_string,
          message: a.message
        }), n.dirty()) : a.kind === "base64" ? Ya.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "base64",
          code: f.invalid_string,
          message: a.message
        }), n.dirty()) : x.assertNever(a);
    return { status: n.value, value: e.data };
  }
  _regex(e, r, n) {
    return this.refinement((s) => e.test(s), {
      validation: r,
      code: f.invalid_string,
      ...g.errToObj(n)
    });
  }
  _addCheck(e) {
    return new _Z({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...g.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...g.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...g.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...g.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...g.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...g.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...g.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...g.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...g.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...g.errToObj(e) });
  }
  datetime(e) {
    var r, n;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      local: false,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (r = e?.offset) !== null && r !== void 0 ? r : false,
      local: (n = e?.local) !== null && n !== void 0 ? n : false,
      ...g.errToObj(e?.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      ...g.errToObj(e?.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...g.errToObj(e) });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...g.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r?.position,
      ...g.errToObj(r?.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...g.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...g.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...g.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...g.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...g.errToObj(r)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e) {
    return this.min(1, g.errToObj(e));
  }
  trim() {
    return new _Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
Z.create = (t) => {
  var e;
  return new Z({
    checks: [],
    typeName: _.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : false,
    ...b(t)
  });
};
function ei(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = r > n ? r : n, a = parseInt(t.toFixed(s).replace(".", "")), i = parseInt(e.toFixed(s).replace(".", ""));
  return a % i / Math.pow(10, s);
}
var Q = class _Q extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== m.number) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f.invalid_type,
        expected: m.number,
        received: a.parsedType
      }), v;
    }
    let n;
    const s = new I();
    for (const a of this._def.checks)
      a.kind === "int" ? x.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), s.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: false,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: false,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? ei(e.data, a.value) !== 0 && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.not_finite,
        message: a.message
      }), s.dirty()) : x.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, true, g.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, false, g.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, true, g.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, false, g.toString(r));
  }
  setLimit(e, r, n, s) {
    return new _Q({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: g.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _Q({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: g.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: g.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: g.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: g.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: g.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: g.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: g.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: g.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: g.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && x.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return true;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
};
Q.create = (t) => new Q({
  checks: [],
  typeName: _.ZodNumber,
  coerce: t?.coerce || false,
  ...b(t)
});
var K = class _K extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== m.bigint) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f.invalid_type,
        expected: m.bigint,
        received: a.parsedType
      }), v;
    }
    let n;
    const s = new I();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : x.assertNever(a);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, true, g.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, false, g.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, true, g.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, false, g.toString(r));
  }
  setLimit(e, r, n, s) {
    return new _K({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: g.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _K({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: g.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: g.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: g.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: g.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: g.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
K.create = (t) => {
  var e;
  return new K({
    checks: [],
    typeName: _.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : false,
    ...b(t)
  });
};
var Ie = class extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== m.boolean) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.boolean,
        received: n.parsedType
      }), v;
    }
    return j(e.data);
  }
};
Ie.create = (t) => new Ie({
  typeName: _.ZodBoolean,
  coerce: t?.coerce || false,
  ...b(t)
});
var ae = class _ae extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== m.date) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f.invalid_type,
        expected: m.date,
        received: a.parsedType
      }), v;
    }
    if (isNaN(e.data.getTime())) {
      const a = this._getOrReturnCtx(e);
      return p(a, {
        code: f.invalid_date
      }), v;
    }
    const n = new I();
    let s;
    for (const a of this._def.checks)
      a.kind === "min" ? e.data.getTime() < a.value && (s = this._getOrReturnCtx(e, s), p(s, {
        code: f.too_small,
        message: a.message,
        inclusive: true,
        exact: false,
        minimum: a.value,
        type: "date"
      }), n.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (s = this._getOrReturnCtx(e, s), p(s, {
        code: f.too_big,
        message: a.message,
        inclusive: true,
        exact: false,
        maximum: a.value,
        type: "date"
      }), n.dirty()) : x.assertNever(a);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new _ae({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: g.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: g.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
};
ae.create = (t) => new ae({
  checks: [],
  coerce: t?.coerce || false,
  typeName: _.ZodDate,
  ...b(t)
});
var Xe = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.symbol) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.symbol,
        received: n.parsedType
      }), v;
    }
    return j(e.data);
  }
};
Xe.create = (t) => new Xe({
  typeName: _.ZodSymbol,
  ...b(t)
});
var je = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.undefined) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.undefined,
        received: n.parsedType
      }), v;
    }
    return j(e.data);
  }
};
je.create = (t) => new je({
  typeName: _.ZodUndefined,
  ...b(t)
});
var Ae = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.null) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.null,
        received: n.parsedType
      }), v;
    }
    return j(e.data);
  }
};
Ae.create = (t) => new Ae({
  typeName: _.ZodNull,
  ...b(t)
});
var ge = class extends w {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e) {
    return j(e.data);
  }
};
ge.create = (t) => new ge({
  typeName: _.ZodAny,
  ...b(t)
});
var se = class extends w {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e) {
    return j(e.data);
  }
};
se.create = (t) => new se({
  typeName: _.ZodUnknown,
  ...b(t)
});
var Y = class extends w {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return p(r, {
      code: f.invalid_type,
      expected: m.never,
      received: r.parsedType
    }), v;
  }
};
Y.create = (t) => new Y({
  typeName: _.ZodNever,
  ...b(t)
});
var Qe = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.undefined) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.void,
        received: n.parsedType
      }), v;
    }
    return j(e.data);
  }
};
Qe.create = (t) => new Qe({
  typeName: _.ZodVoid,
  ...b(t)
});
var U2 = class _U extends w {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e), s = this._def;
    if (r.parsedType !== m.array)
      return p(r, {
        code: f.invalid_type,
        expected: m.array,
        received: r.parsedType
      }), v;
    if (s.exactLength !== null) {
      const i = r.data.length > s.exactLength.value, o = r.data.length < s.exactLength.value;
      (i || o) && (p(r, {
        code: i ? f.too_big : f.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: i ? s.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && r.data.length < s.minLength.value && (p(r, {
      code: f.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (p(r, {
      code: f.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((i, o) => s.type._parseAsync(new B(r, i, r.path, o)))).then((i) => I.mergeArray(n, i));
    const a = [...r.data].map((i, o) => s.type._parseSync(new B(r, i, r.path, o)));
    return I.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new _U({
      ...this._def,
      minLength: { value: e, message: g.toString(r) }
    });
  }
  max(e, r) {
    return new _U({
      ...this._def,
      maxLength: { value: e, message: g.toString(r) }
    });
  }
  length(e, r) {
    return new _U({
      ...this._def,
      exactLength: { value: e, message: g.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
U2.create = (t, e) => new U2({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: _.ZodArray,
  ...b(e)
});
function fe(t) {
  if (t instanceof C) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = z.create(fe(n));
    }
    return new C({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof U2 ? new U2({
      ...t._def,
      type: fe(t.element)
    }) : t instanceof z ? z.create(fe(t.unwrap())) : t instanceof te ? te.create(fe(t.unwrap())) : t instanceof V ? V.create(t.items.map((e) => fe(e))) : t;
}
var C = class _C extends w {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = x.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== m.object) {
      const u = this._getOrReturnCtx(e);
      return p(u, {
        code: f.invalid_type,
        expected: m.object,
        received: u.parsedType
      }), v;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: a, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Y && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        i.includes(u) || o.push(u);
    const c = [];
    for (const u of i) {
      const d = a[u], h = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: d._parse(new B(s, h, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof Y) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const d of o)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: s.data[d] }
          });
      else if (u === "strict")
        o.length > 0 && (p(s, {
          code: f.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const d of o) {
        const h = s.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: u._parse(
            new B(s, h, s.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const d of c) {
        const h = await d.key, y = await d.value;
        u.push({
          key: h,
          value: y,
          alwaysSet: d.alwaysSet
        });
      }
      return u;
    }).then((u) => I.mergeObjectSync(n, u)) : I.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return g.errToObj, new _C({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n) => {
          var s, a, i, o;
          const c = (i = (a = (s = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(s, r, n).message) !== null && i !== void 0 ? i : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = g.errToObj(e).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new _C({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _C({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new _C({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new _C({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: _.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new _C({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return x.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      e[n] || (r[n] = this.shape[n]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return fe(this);
  }
  partial(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      const s = this.shape[n];
      e && !e[n] ? r[n] = s : r[n] = s.optional();
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        r[n] = this.shape[n];
      else {
        let a = this.shape[n];
        for (; a instanceof z; )
          a = a._def.innerType;
        r[n] = a;
      }
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return hn(x.objectKeys(this.shape));
  }
};
C.create = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strip",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...b(e)
});
C.strictCreate = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strict",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...b(e)
});
C.lazycreate = (t, e) => new C({
  shape: t,
  unknownKeys: "strip",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...b(e)
});
var Le = class extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.options;
    function s(a) {
      for (const o of a)
        if (o.result.status === "valid")
          return o.result;
      for (const o of a)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const i = a.map((o) => new L(o.ctx.common.issues));
      return p(r, {
        code: f.invalid_union,
        unionErrors: i
      }), v;
    }
    if (r.common.async)
      return Promise.all(n.map(async (a) => {
        const i = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: r.data,
            path: r.path,
            parent: i
          }),
          ctx: i
        };
      })).then(s);
    {
      let a;
      const i = [];
      for (const c of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !a && (a = { result: d, ctx: u }), u.common.issues.length && i.push(u.common.issues);
      }
      if (a)
        return r.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((c) => new L(c));
      return p(r, {
        code: f.invalid_union,
        unionErrors: o
      }), v;
    }
  }
  get options() {
    return this._def.options;
  }
};
Le.create = (t, e) => new Le({
  options: t,
  typeName: _.ZodUnion,
  ...b(e)
});
var G = (t) => t instanceof De ? G(t.schema) : t instanceof W2 ? G(t.innerType()) : t instanceof Ze ? [t.value] : t instanceof ee ? t.options : t instanceof Ue ? x.objectValues(t.enum) : t instanceof We ? G(t._def.innerType) : t instanceof je ? [void 0] : t instanceof Ae ? [null] : t instanceof z ? [void 0, ...G(t.unwrap())] : t instanceof te ? [null, ...G(t.unwrap())] : t instanceof Gt || t instanceof ze ? G(t.unwrap()) : t instanceof qe ? G(t._def.innerType) : [];
var dt = class _dt extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.object)
      return p(r, {
        code: f.invalid_type,
        expected: m.object,
        received: r.parsedType
      }), v;
    const n = this.discriminator, s = r.data[n], a = this.optionsMap.get(s);
    return a ? r.common.async ? a._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : a._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (p(r, {
      code: f.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), v);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n) {
    const s = /* @__PURE__ */ new Map();
    for (const a of r) {
      const i = G(a.shape[e]);
      if (!i.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of i) {
        if (s.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        s.set(o, a);
      }
    }
    return new _dt({
      typeName: _.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: s,
      ...b(n)
    });
  }
};
function It(t, e) {
  const r = X(t), n = X(e);
  if (t === e)
    return { valid: true, data: t };
  if (r === m.object && n === m.object) {
    const s = x.objectKeys(e), a = x.objectKeys(t).filter((o) => s.indexOf(o) !== -1), i = { ...t, ...e };
    for (const o of a) {
      const c = It(t[o], e[o]);
      if (!c.valid)
        return { valid: false };
      i[o] = c.data;
    }
    return { valid: true, data: i };
  } else if (r === m.array && n === m.array) {
    if (t.length !== e.length)
      return { valid: false };
    const s = [];
    for (let a = 0; a < t.length; a++) {
      const i = t[a], o = e[a], c = It(i, o);
      if (!c.valid)
        return { valid: false };
      s.push(c.data);
    }
    return { valid: true, data: s };
  } else
    return r === m.date && n === m.date && +t == +e ? { valid: true, data: t } : { valid: false };
}
var $e = class extends w {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = (a, i) => {
      if (Pt(a) || Pt(i))
        return v;
      const o = It(a.value, i.value);
      return o.valid ? ((Nt(a) || Nt(i)) && r.dirty(), { status: r.value, value: o.data }) : (p(n, {
        code: f.invalid_intersection_types
      }), v);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([a, i]) => s(a, i)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
$e.create = (t, e, r) => new $e({
  left: t,
  right: e,
  typeName: _.ZodIntersection,
  ...b(r)
});
var V = class _V extends w {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== m.array)
      return p(n, {
        code: f.invalid_type,
        expected: m.array,
        received: n.parsedType
      }), v;
    if (n.data.length < this._def.items.length)
      return p(n, {
        code: f.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), v;
    !this._def.rest && n.data.length > this._def.items.length && (p(n, {
      code: f.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), r.dirty());
    const a = [...n.data].map((i, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new B(n, i, n.path, o)) : null;
    }).filter((i) => !!i);
    return n.common.async ? Promise.all(a).then((i) => I.mergeArray(r, i)) : I.mergeArray(r, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new _V({
      ...this._def,
      rest: e
    });
  }
};
V.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new V({
    items: t,
    typeName: _.ZodTuple,
    rest: null,
    ...b(e)
  });
};
var Me = class _Me extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== m.object)
      return p(n, {
        code: f.invalid_type,
        expected: m.object,
        received: n.parsedType
      }), v;
    const s = [], a = this._def.keyType, i = this._def.valueType;
    for (const o in n.data)
      s.push({
        key: a._parse(new B(n, o, n.path, o)),
        value: i._parse(new B(n, n.data[o], n.path, o)),
        alwaysSet: o in n.data
      });
    return n.common.async ? I.mergeObjectAsync(r, s) : I.mergeObjectSync(r, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof w ? new _Me({
      keyType: e,
      valueType: r,
      typeName: _.ZodRecord,
      ...b(n)
    }) : new _Me({
      keyType: Z.create(),
      valueType: e,
      typeName: _.ZodRecord,
      ...b(r)
    });
  }
};
var Ke = class extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== m.map)
      return p(n, {
        code: f.invalid_type,
        expected: m.map,
        received: n.parsedType
      }), v;
    const s = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([o, c], u) => ({
      key: s._parse(new B(n, o, n.path, [u, "key"])),
      value: a._parse(new B(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const u = await c.key, d = await c.value;
          if (u.status === "aborted" || d.status === "aborted")
            return v;
          (u.status === "dirty" || d.status === "dirty") && r.dirty(), o.set(u.value, d.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of i) {
        const u = c.key, d = c.value;
        if (u.status === "aborted" || d.status === "aborted")
          return v;
        (u.status === "dirty" || d.status === "dirty") && r.dirty(), o.set(u.value, d.value);
      }
      return { status: r.value, value: o };
    }
  }
};
Ke.create = (t, e, r) => new Ke({
  valueType: e,
  keyType: t,
  typeName: _.ZodMap,
  ...b(r)
});
var ie = class _ie extends w {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== m.set)
      return p(n, {
        code: f.invalid_type,
        expected: m.set,
        received: n.parsedType
      }), v;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (p(n, {
      code: f.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.minSize.message
    }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (p(n, {
      code: f.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.maxSize.message
    }), r.dirty());
    const a = this._def.valueType;
    function i(c) {
      const u = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return v;
        d.status === "dirty" && r.dirty(), u.add(d.value);
      }
      return { status: r.value, value: u };
    }
    const o = [...n.data.values()].map((c, u) => a._parse(new B(n, c, n.path, u)));
    return n.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(e, r) {
    return new _ie({
      ...this._def,
      minSize: { value: e, message: g.toString(r) }
    });
  }
  max(e, r) {
    return new _ie({
      ...this._def,
      maxSize: { value: e, message: g.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
ie.create = (t, e) => new ie({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: _.ZodSet,
  ...b(e)
});
var he = class _he extends w {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.function)
      return p(r, {
        code: f.invalid_type,
        expected: m.function,
        received: r.parsedType
      }), v;
    function n(o, c) {
      return Ge({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Je(),
          ye
        ].filter((u) => !!u),
        issueData: {
          code: f.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(o, c) {
      return Ge({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Je(),
          ye
        ].filter((u) => !!u),
        issueData: {
          code: f.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const a = { errorMap: r.common.contextualErrorMap }, i = r.data;
    if (this._def.returns instanceof _e) {
      const o = this;
      return j(async function(...c) {
        const u = new L([]), d = await o._def.args.parseAsync(c, a).catch((k2) => {
          throw u.addIssue(n(c, k2)), u;
        }), h = await Reflect.apply(i, this, d);
        return await o._def.returns._def.type.parseAsync(h, a).catch((k2) => {
          throw u.addIssue(s(h, k2)), u;
        });
      });
    } else {
      const o = this;
      return j(function(...c) {
        const u = o._def.args.safeParse(c, a);
        if (!u.success)
          throw new L([n(c, u.error)]);
        const d = Reflect.apply(i, this, u.data), h = o._def.returns.safeParse(d, a);
        if (!h.success)
          throw new L([s(d, h.error)]);
        return h.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new _he({
      ...this._def,
      args: V.create(e).rest(se.create())
    });
  }
  returns(e) {
    return new _he({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new _he({
      args: e || V.create([]).rest(se.create()),
      returns: r || se.create(),
      typeName: _.ZodFunction,
      ...b(n)
    });
  }
};
var De = class extends w {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
};
De.create = (t, e) => new De({
  getter: t,
  typeName: _.ZodLazy,
  ...b(e)
});
var Ze = class extends w {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return p(r, {
        received: r.data,
        code: f.invalid_literal,
        expected: this._def.value
      }), v;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
Ze.create = (t, e) => new Ze({
  value: t,
  typeName: _.ZodLiteral,
  ...b(e)
});
function hn(t, e) {
  return new ee({
    values: t,
    typeName: _.ZodEnum,
    ...b(e)
  });
}
var ee = class _ee extends w {
  constructor() {
    super(...arguments), Ee.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return p(r, {
        expected: x.joinValues(n),
        received: r.parsedType,
        code: f.invalid_type
      }), v;
    }
    if (Ye(this, Ee, "f") || ln(this, Ee, new Set(this._def.values), "f"), !Ye(this, Ee, "f").has(e.data)) {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return p(r, {
        received: r.data,
        code: f.invalid_enum_value,
        options: n
      }), v;
    }
    return j(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return _ee.create(e, {
      ...this._def,
      ...r
    });
  }
  exclude(e, r = this._def) {
    return _ee.create(this.options.filter((n) => !e.includes(n)), {
      ...this._def,
      ...r
    });
  }
};
Ee = /* @__PURE__ */ new WeakMap();
ee.create = hn;
var Ue = class extends w {
  constructor() {
    super(...arguments), Ce.set(this, void 0);
  }
  _parse(e) {
    const r = x.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== m.string && n.parsedType !== m.number) {
      const s = x.objectValues(r);
      return p(n, {
        expected: x.joinValues(s),
        received: n.parsedType,
        code: f.invalid_type
      }), v;
    }
    if (Ye(this, Ce, "f") || ln(this, Ce, new Set(x.getValidEnumValues(this._def.values)), "f"), !Ye(this, Ce, "f").has(e.data)) {
      const s = x.objectValues(r);
      return p(n, {
        received: n.data,
        code: f.invalid_enum_value,
        options: s
      }), v;
    }
    return j(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
Ce = /* @__PURE__ */ new WeakMap();
Ue.create = (t, e) => new Ue({
  values: t,
  typeName: _.ZodNativeEnum,
  ...b(e)
});
var _e = class extends w {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.promise && r.common.async === false)
      return p(r, {
        code: f.invalid_type,
        expected: m.promise,
        received: r.parsedType
      }), v;
    const n = r.parsedType === m.promise ? r.data : Promise.resolve(r.data);
    return j(n.then((s) => this._def.type.parseAsync(s, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
};
_e.create = (t, e) => new _e({
  type: t,
  typeName: _.ZodPromise,
  ...b(e)
});
var W2 = class extends w {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === _.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = this._def.effect || null, a = {
      addIssue: (i) => {
        p(n, i), i.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), s.type === "preprocess") {
      const i = s.transform(n.data, a);
      if (n.common.async)
        return Promise.resolve(i).then(async (o) => {
          if (r.value === "aborted")
            return v;
          const c = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n
          });
          return c.status === "aborted" ? v : c.status === "dirty" || r.value === "dirty" ? pe(c.value) : c;
        });
      {
        if (r.value === "aborted")
          return v;
        const o = this._def.schema._parseSync({
          data: i,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? v : o.status === "dirty" || r.value === "dirty" ? pe(o.value) : o;
      }
    }
    if (s.type === "refinement") {
      const i = (o) => {
        const c = s.refinement(o, a);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === false) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? v : (o.status === "dirty" && r.dirty(), i(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? v : (o.status === "dirty" && r.dirty(), i(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === false) {
        const i = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!Pe(i))
          return i;
        const o = s.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => Pe(i) ? Promise.resolve(s.transform(i.value, a)).then((o) => ({ status: r.value, value: o })) : i);
    x.assertNever(s);
  }
};
W2.create = (t, e, r) => new W2({
  schema: t,
  typeName: _.ZodEffects,
  effect: e,
  ...b(r)
});
W2.createWithPreprocess = (t, e, r) => new W2({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: _.ZodEffects,
  ...b(r)
});
var z = class extends w {
  _parse(e) {
    return this._getType(e) === m.undefined ? j(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
z.create = (t, e) => new z({
  innerType: t,
  typeName: _.ZodOptional,
  ...b(e)
});
var te = class extends w {
  _parse(e) {
    return this._getType(e) === m.null ? j(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
te.create = (t, e) => new te({
  innerType: t,
  typeName: _.ZodNullable,
  ...b(e)
});
var We = class extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return r.parsedType === m.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
We.create = (t, e) => new We({
  innerType: t,
  typeName: _.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...b(e)
});
var qe = class extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Ne(s) ? s.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new L(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new L(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
qe.create = (t, e) => new qe({
  innerType: t,
  typeName: _.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...b(e)
});
var et = class extends w {
  _parse(e) {
    if (this._getType(e) !== m.nan) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.nan,
        received: n.parsedType
      }), v;
    }
    return { status: "valid", value: e.data };
  }
};
et.create = (t) => new et({
  typeName: _.ZodNaN,
  ...b(t)
});
var ti = Symbol("zod_brand");
var Gt = class extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var Be = class _Be extends w {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? v : a.status === "dirty" ? (r.dirty(), pe(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? v : s.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, r) {
    return new _Be({
      in: e,
      out: r,
      typeName: _.ZodPipeline
    });
  }
};
var ze = class extends w {
  _parse(e) {
    const r = this._def.innerType._parse(e), n = (s) => (Pe(s) && (s.value = Object.freeze(s.value)), s);
    return Ne(r) ? r.then((s) => n(s)) : n(r);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ze.create = (t, e) => new ze({
  innerType: t,
  typeName: _.ZodReadonly,
  ...b(e)
});
function mn(t, e = {}, r) {
  return t ? ge.create().superRefine((n, s) => {
    var a, i;
    if (!t(n)) {
      const o = typeof e == "function" ? e(n) : typeof e == "string" ? { message: e } : e, c = (i = (a = o.fatal) !== null && a !== void 0 ? a : r) !== null && i !== void 0 ? i : true, u = typeof o == "string" ? { message: o } : o;
      s.addIssue({ code: "custom", ...u, fatal: c });
    }
  }) : ge.create();
}
var ri = {
  object: C.lazycreate
};
var _;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(_ || (_ = {}));
var ni = (t, e = {
  message: `Input not instance of ${t.name}`
}) => mn((r) => r instanceof t, e);
var yn = Z.create;
var gn = Q.create;
var si = et.create;
var ai = K.create;
var _n = Ie.create;
var ii = ae.create;
var oi = Xe.create;
var ci = je.create;
var ui = Ae.create;
var li = ge.create;
var di = se.create;
var fi = Y.create;
var pi = Qe.create;
var hi = U2.create;
var mi = C.create;
var yi = C.strictCreate;
var gi = Le.create;
var _i = dt.create;
var vi = $e.create;
var bi = V.create;
var wi = Me.create;
var xi = Ke.create;
var ki = ie.create;
var Ti = he.create;
var Ei = De.create;
var Ci = Ze.create;
var Ri = ee.create;
var Oi = Ue.create;
var Si = _e.create;
var vr = W2.create;
var Pi = z.create;
var Ni = te.create;
var Ii = W2.createWithPreprocess;
var ji = Be.create;
var Ai = () => yn().optional();
var Li = () => gn().optional();
var $i = () => _n().optional();
var Mi = {
  string: (t) => Z.create({ ...t, coerce: true }),
  number: (t) => Q.create({ ...t, coerce: true }),
  boolean: (t) => Ie.create({
    ...t,
    coerce: true
  }),
  bigint: (t) => K.create({ ...t, coerce: true }),
  date: (t) => ae.create({ ...t, coerce: true })
};
var Di = v;
var l = Object.freeze({
  __proto__: null,
  defaultErrorMap: ye,
  setErrorMap: Da,
  getErrorMap: Je,
  makeIssue: Ge,
  EMPTY_PATH: Za,
  addIssueToContext: p,
  ParseStatus: I,
  INVALID: v,
  DIRTY: pe,
  OK: j,
  isAborted: Pt,
  isDirty: Nt,
  isValid: Pe,
  isAsync: Ne,
  get util() {
    return x;
  },
  get objectUtil() {
    return St;
  },
  ZodParsedType: m,
  getParsedType: X,
  ZodType: w,
  datetimeRegex: pn,
  ZodString: Z,
  ZodNumber: Q,
  ZodBigInt: K,
  ZodBoolean: Ie,
  ZodDate: ae,
  ZodSymbol: Xe,
  ZodUndefined: je,
  ZodNull: Ae,
  ZodAny: ge,
  ZodUnknown: se,
  ZodNever: Y,
  ZodVoid: Qe,
  ZodArray: U2,
  ZodObject: C,
  ZodUnion: Le,
  ZodDiscriminatedUnion: dt,
  ZodIntersection: $e,
  ZodTuple: V,
  ZodRecord: Me,
  ZodMap: Ke,
  ZodSet: ie,
  ZodFunction: he,
  ZodLazy: De,
  ZodLiteral: Ze,
  ZodEnum: ee,
  ZodNativeEnum: Ue,
  ZodPromise: _e,
  ZodEffects: W2,
  ZodTransformer: W2,
  ZodOptional: z,
  ZodNullable: te,
  ZodDefault: We,
  ZodCatch: qe,
  ZodNaN: et,
  BRAND: ti,
  ZodBranded: Gt,
  ZodPipeline: Be,
  ZodReadonly: ze,
  custom: mn,
  Schema: w,
  ZodSchema: w,
  late: ri,
  get ZodFirstPartyTypeKind() {
    return _;
  },
  coerce: Mi,
  any: li,
  array: hi,
  bigint: ai,
  boolean: _n,
  date: ii,
  discriminatedUnion: _i,
  effect: vr,
  enum: Ri,
  function: Ti,
  instanceof: ni,
  intersection: vi,
  lazy: Ei,
  literal: Ci,
  map: xi,
  nan: si,
  nativeEnum: Oi,
  never: fi,
  null: ui,
  nullable: Ni,
  number: gn,
  object: mi,
  oboolean: $i,
  onumber: Li,
  optional: Pi,
  ostring: Ai,
  pipeline: ji,
  preprocess: Ii,
  promise: Si,
  record: wi,
  set: ki,
  strictObject: yi,
  string: yn,
  symbol: oi,
  transformer: vr,
  tuple: bi,
  undefined: ci,
  union: gi,
  unknown: di,
  void: pi,
  NEVER: Di,
  ZodIssueCode: f,
  quotelessJson: Ma,
  ZodError: L
});
var vn = /^0x[0-9a-f]+$/i;
var bn = /^\d+$/;
var Zi = l.string().min(1, "The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (t) => !vn.test(t),
  "The shortString should not be a hex string"
).refine(
  (t) => !bn.test(t),
  "The shortString should not be an integer string"
);
var D = l.union([
  l.string().regex(
    vn,
    "Only hex, integers and bigint are supported in calldata"
  ),
  l.string().regex(
    bn,
    "Only hex, integers and bigint are supported in calldata"
  ),
  Zi,
  l.number().int("Only hex, integers and bigint are supported in calldata"),
  l.bigint()
]);
var tt = l.object({
  contractAddress: l.string(),
  entrypoint: l.string(),
  calldata: l.array(D.or(l.array(D))).optional()
});
var jt = l.array(tt).nonempty();
var Ui = l.object({
  types: l.record(
    l.array(
      l.union([
        l.object({
          name: l.string(),
          type: l.literal("merkletree"),
          contains: l.string()
        }),
        l.object({
          name: l.string(),
          type: l.literal("enum"),
          contains: l.string()
        }),
        l.object({
          name: l.string(),
          type: l.string()
        })
      ])
    )
  ),
  primaryType: l.string(),
  domain: l.record(l.unknown()),
  message: l.record(l.unknown())
});
var At = l.object({
  type: l.literal("ERC20"),
  options: l.object({
    address: l.string(),
    symbol: l.string().optional(),
    decimals: l.number().optional(),
    image: l.string().optional(),
    name: l.string().optional()
  })
});
var Wi = l.union([
  l.object({
    id: l.string(),
    chain_id: l.string(),
    chain_name: l.string(),
    rpc_urls: l.array(l.string()).optional(),
    native_currency: At.optional(),
    block_explorer_url: l.array(l.string()).optional()
  }),
  l.object({
    id: l.string(),
    chainId: l.string(),
    chainName: l.string(),
    rpcUrls: l.array(l.string()).optional(),
    nativeCurrency: At.optional(),
    blockExplorerUrl: l.array(l.string()).optional()
  }).transform((t) => ({
    id: t.id,
    chain_id: t.chainId,
    chain_name: t.chainName,
    rpc_urls: t.rpcUrls,
    native_currency: t.nativeCurrency,
    block_explorer_url: t.blockExplorerUrl
  }))
]);
var xt = {
  enable: l.tuple([
    l.object({
      starknetVersion: l.union([l.literal("v3"), l.literal("v4"), l.literal("v5")]).optional()
    }).optional()
  ]).or(l.tuple([])),
  addStarknetChain: l.tuple([Wi]),
  switchStarknetChain: l.tuple([
    l.object({
      chainId: l.string()
    })
  ]),
  watchAsset: l.tuple([At]),
  requestAccounts: l.tuple([
    l.object({
      silent_mode: l.boolean().optional()
    })
  ]),
  execute: l.tuple([
    jt.or(tt),
    l.object({
      nonce: D.optional(),
      maxFee: D.optional(),
      version: D.optional()
    }).optional()
  ]),
  signMessage: l.tuple([Ui])
};
l.tuple([
  jt.or(tt),
  l.object({
    nonce: D.optional(),
    maxFee: D.optional(),
    version: D.optional()
  }).optional()
]).or(
  l.tuple([
    jt.or(tt),
    l.array(l.any()).optional(),
    l.object({
      nonce: D.optional(),
      maxFee: D.optional(),
      version: D.optional()
    }).optional()
  ])
);
var wn = l.object({
  contract_address: l.string(),
  entry_point: l.string(),
  calldata: l.array(D).optional()
}).transform(({ contract_address: t, entry_point: e, calldata: r }) => ({
  contractAddress: t,
  entrypoint: e,
  calldata: r || []
}));
var qi = l.array(wn).nonempty();
var zi = {
  ZERO: 0,
  ONE: 1
};
var Bi = l.object({
  address: l.string(),
  class_hash: l.string(),
  salt: l.string(),
  calldata: l.array(l.string()),
  sigdata: l.array(l.string()).optional(),
  //version: z.literal([0, 1]),
  version: l.nativeEnum(zi)
  // allow only 0 | 1, workaround since zod doesn't support literals as numbers
});
var P = ks.create({
  isServer: false,
  allowOutsideOfServer: true
});
var Lt = kr;
var $t = "";
var xn = "";
var Mt = ({
  width: t = 775,
  height: e = 385,
  origin: r,
  location: n,
  atLeftBottom: s = false
}) => {
  const a = window?.outerWidth ?? window?.innerWidth ?? window?.screen.width ?? 0, i = window?.outerHeight ?? window?.innerHeight ?? window?.screen.height ?? 0, o = window?.screenLeft ?? window?.screenX ?? 0, c = window?.screenTop ?? window?.screenY ?? 0, u = s ? 0 : o + a / 2 - t / 2, d = s ? window.screen.availHeight + 10 : c + i / 2 - e / 2;
  Lt = r ?? Lt, $t = n ?? $t, xn = `width=${t},height=${e},top=${d},left=${u},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`;
};
P.router({
  authorize: P.procedure.output(l.boolean()).mutation(async () => true),
  connect: P.procedure.mutation(async () => ""),
  connectWebwallet: P.procedure.input(
    l.object({
      theme: l.enum(["light", "dark", "auto"]).optional()
    })
  ).output(
    l.object({
      account: l.string().array().optional(),
      chainId: l.string().optional()
    })
  ).mutation(async () => ({})),
  connectWebwalletSSO: P.procedure.input(
    l.object({ token: l.string(), authorizedPartyId: l.string().optional() })
  ).output(
    l.object({
      account: l.string().array().optional(),
      chainId: l.string().optional()
    })
  ).mutation(async () => ({})),
  enable: P.procedure.output(l.string()).mutation(async () => ""),
  execute: P.procedure.input(xt.execute).output(l.string()).mutation(async () => ""),
  signMessage: P.procedure.input(xt.signMessage).output(l.string().array()).mutation(async () => []),
  getLoginStatus: P.procedure.output(
    l.object({
      isLoggedIn: l.boolean(),
      hasSession: l.boolean().optional(),
      isPreauthorized: l.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: true
  })),
  // RPC Messages
  requestAccounts: P.procedure.input(l.object({ silent_mode: l.boolean().optional() })).output(l.string().array()).mutation(async () => []),
  requestChainId: P.procedure.output(l.string()).mutation(async () => ""),
  signTypedData: P.procedure.input(xt.signMessage).output(l.string().array()).mutation(async () => []),
  getPermissions: P.procedure.output(l.array(l.enum([k.ACCOUNTS]))).mutation(async () => [k.ACCOUNTS]),
  addInvokeTransaction: P.procedure.input(wn.or(qi)).output(l.string()).mutation(async (t) => ""),
  addStarknetChain: P.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: P.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  watchAsset: P.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  updateModal: P.procedure.subscription(async () => {
  }),
  deploymentData: P.procedure.output(Bi).mutation(async () => ({
    address: "",
    calldata: [],
    version: 0,
    class_hash: "",
    salt: ""
  }))
});
var kt = ({
  iframe: t
}) => cs({
  links: [
    ns({
      enabled: (e) => typeof window < "u" || e.direction === "down" && e.result instanceof Error
    }),
    Bn({
      condition(e) {
        if (!t && e.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!t;
      },
      true: Ct.windowLink({
        window,
        postWindow: t,
        postOrigin: "*"
      }),
      false: Ct.popupLink({
        listenWindow: window,
        createPopup: () => {
          let e = null;
          const r = document.createElement("button");
          if (r.style.display = "none", r.addEventListener("click", () => {
            e = window.open(
              `${Lt}${$t}`,
              "popup",
              xn
            );
          }), r.click(), (async () => {
            for (; !e; )
              await new Promise((n) => setTimeout(n, 100));
          })(), !e)
            throw new Error("Could not open popup");
          return e;
        },
        postOrigin: "*"
      })
    })
  ]
});
var He = [];
var Vi = (t, e) => ({
  ...t,
  getLoginStatus: () => e.getLoginStatus.mutate(),
  connectWebwallet: (n = {}) => {
    const { theme: s } = n;
    return e.connectWebwallet.mutate({ theme: s });
  },
  connectWebwalletSSO: (n, s) => e.connectWebwalletSSO.mutate({ token: n, authorizedPartyId: s }),
  async request(n) {
    switch (n.type) {
      case "wallet_requestAccounts":
        return e.requestAccounts.mutate(n.params);
      case "wallet_signTypedData": {
        const s = n.params, a = s?.primaryType === "Session" && s?.domain.name === "SessionAccount.session";
        Mt({
          width: $n,
          height: Mn,
          location: a ? "/signSessionKeys" : "/signMessage"
        });
        const i = Array.isArray(n.params) ? n.params : [n.params];
        return e.signTypedData.mutate(i);
      }
      case "wallet_getPermissions":
        return e.getPermissions.mutate();
      case "wallet_addInvokeTransaction": {
        const s = n.params.calls;
        return Mt({
          width: An,
          height: Ln,
          location: "/review"
        }), { transaction_hash: await e.addInvokeTransaction.mutate(s) };
      }
      case "wallet_requestChainId":
        return await e.requestChainId.mutate();
      case "wallet_addStarknetChain":
        return e.addStarknetChain.mutate(n.params);
      case "wallet_switchStarknetChain":
        return e.switchStarknetChain.mutate(n.params);
      case "wallet_watchAsset":
        return e.watchAsset.mutate();
      case "wallet_deploymentData":
        return e.deploymentData.mutate();
      default:
        throw new Error("not implemented");
    }
  },
  on: (n, s) => {
    if (n === "accountsChanged")
      He.push({
        type: n,
        handler: s
      });
    else if (n === "networkChanged")
      He.push({
        type: n,
        handler: s
      });
    else
      throw new Error(`Unknwown event: ${n}`);
  },
  off: (n, s) => {
    if (n !== "accountsChanged" && n !== "networkChanged")
      throw new Error(`Unknwown event: ${n}`);
    const a = He.findIndex(
      (i) => i.type === n && i.handler === s
    );
    a >= 0 && He.splice(a, 1);
  }
});
var Hi = (t) => {
  t.style.position = "fixed", t.style.top = "50%", t.style.left = "50%", t.style.transform = "translate(-50%, -50%)", t.style.width = "380px", t.style.height = "420px", t.style.border = "none", t.style.borderRadius = "40px", t.style.boxShadow = "0px 4px 20px rgba(0, 0, 0, 0.5)";
  const e = document.createElement("div");
  return e.style.display = "none", e.style.position = "fixed", e.style.top = "0", e.style.left = "0", e.style.right = "0", e.style.bottom = "0", e.style.zIndex = "99999", e.style.backdropFilter = "blur(4px)", e.appendChild(t), e;
};
var Fi = (t) => {
  t.style.display = "block";
};
var Ji = (t) => {
  t.style.display = "none";
};
var Gi = (t, e) => {
  t.style.height = `min(${e || 420}px, 100%)`;
};
var Yi = (t, e) => {
  t.style.width = `min(${e || 380}px, 100%)`;
};
var Xi = (t, e, r) => {
  t.style.width = `min(${e || 380}px, 100%)`, t.style.height = `min(${r || 420}px, 100%)`;
};
var Qi = async (t, e) => {
  const r = new URL(t);
  r.pathname = "/iframes/comms", t = r.toString();
  const n = document.createElement("iframe");
  n.src = t, n.loading = "eager", n.sandbox.add(
    "allow-scripts",
    "allow-same-origin",
    "allow-forms",
    "allow-top-navigation",
    "allow-popups"
  ), n.allow = "clipboard-write", n.id = "argent-webwallet-iframe";
  const s = Hi(n);
  return s.style.display = e ? "block" : "none", s.id = "argent-webwallet-modal", window.document.body.appendChild(s), await new Promise((a, i) => {
    const o = setTimeout(
      () => i(new Error("Timeout while loading an iframe")),
      2e4
    );
    n.addEventListener("load", async () => {
      clearTimeout(o), a();
    });
  }), { iframe: n, modal: s };
};
var Tt = async (t, e, r) => {
  const n = typeof window < "u" ? window : void 0;
  if (!n)
    throw new Error("window is not defined");
  const s = Vi(
    {
      host: n.location.origin,
      id: "argentWebWallet",
      icon: "https://www.argent.xyz/favicon.ico",
      name: "Argent Web Wallet",
      version: "1.0.0"
    },
    e
  );
  if (r) {
    const { iframe: a, modal: i } = r;
    e.updateModal.subscribe(void 0, {
      onData(o) {
        switch (o.action) {
          case "show":
            Fi(i);
            break;
          case "hide":
            Ji(i);
            break;
          case "updateHeight":
            Gi(a, o.height);
            break;
          case "updateWidth":
            Yi(a, o.width);
            break;
          case "updateSize":
            Xi(a, o.width, o.height);
            break;
        }
      }
    });
  }
  return s;
};
var br = "allowed-dapps";
var Ki = async (t) => {
  const e = t === constants_exports.NetworkName.SN_MAIN ? Nn : Pn;
  try {
    const n = await (await caches.open(br)).match(e);
    if (n) {
      const u = parseInt(
        n.headers.get("X-Cache-Timestamp") ?? "0",
        10
      );
      if (((/* @__PURE__ */ new Date()).getTime() - u) / (1e3 * 60 * 60) < 24)
        return n.json();
    }
    const s = await fetch(e), a = new Headers(s.headers);
    a.set("X-Cache-Timestamp", (/* @__PURE__ */ new Date()).getTime().toString());
    const i = await s.json(), o = new Response(JSON.stringify(i), {
      status: s.status,
      statusText: s.statusText,
      headers: a
    });
    return await (await caches.open(br)).put(e, o), i;
  } catch (r) {
    throw new Error(r);
  }
};
var eo = async (t) => new Promise((e) => {
  if (!t)
    return e(false);
  try {
    navigator.webkitTemporaryStorage.queryUsageAndQuota(
      (n, s) => {
        e(
          Math.round(s / (1024 * 1024)) < Math.round(
            (performance?.memory?.jsHeapSizeLimit ?? 1073741824) / (1024 * 1024)
          ) * 2
        );
      },
      () => e(false)
    );
  } catch {
    e(false);
  }
});
var to = async (t) => {
  const { userAgent: e } = navigator, r = !!(navigator.vendor && navigator.vendor.indexOf("Google") === 0 && navigator.brave === void 0 && !e.match(/Edg/) && !e.match(/OPR/)), n = await eo(r);
  if (!r || n) {
    const i = kt({});
    return await Tt(
      t,
      i,
      void 0
    );
  }
  const s = jn(t), { allowedDapps: a } = await Ki(s);
  if (a.includes(window.location.hostname)) {
    const i = "argent-webwallet-modal", o = "argent-webwallet-iframe", c = document.getElementById(i), u = document.getElementById(o);
    c && c && u && (c.remove(), u.remove());
    const { iframe: d, modal: h } = await Qi(t, false), y = kt({
      iframe: d.contentWindow ?? void 0
    });
    return await Tt(
      t,
      y,
      { modal: h, iframe: d }
    );
  } else {
    const i = kt({});
    return await Tt(
      t,
      i,
      void 0
    );
  }
};
var M = null;
var ue = null;
var oo = class extends F {
  constructor(r = {}) {
    super();
    pt(this, "_wallet", null);
    pt(this, "_options");
    this._options = r;
  }
  available() {
    return true;
  }
  async ready() {
    if (!M)
      return this._wallet = null, ue = null, false;
    this._wallet = M;
    try {
      return (await this._wallet.request({
        type: "wallet_getPermissions"
      })).includes(k.ACCOUNTS);
    } catch {
      return false;
    }
  }
  get id() {
    return this._wallet = M, this._wallet?.id || "argentWebWallet";
  }
  get name() {
    return this._wallet = M, this._wallet?.name || "Argent Web Wallet";
  }
  get icon() {
    return {
      light: rr,
      dark: rr
    };
  }
  get wallet() {
    if (!this._wallet)
      throw new A();
    return this._wallet;
  }
  get title() {
    return "Email";
  }
  get subtitle() {
    return "Powered by Argent";
  }
  async connect(r = {}) {
    if (await this.ensureWallet(), !this._wallet)
      throw new S();
    try {
      let n, s;
      if (this._options.ssoToken) {
        const i = await this._wallet.connectWebwalletSSO(
          this._options.ssoToken,
          this._options.authorizedPartyId
        );
        n = i.account, s = i.chainId;
      } else {
        const i = await this._wallet.connectWebwallet({ theme: this._options.theme });
        n = i.account, s = i.chainId;
      }
      if (!n || !s)
        return {};
      const a = S2(s);
      return ue = n[0], {
        account: n[0],
        chainId: BigInt(a)
      };
    } catch {
      throw new R();
    }
  }
  async request(r) {
    if (!this._wallet)
      throw new A();
    try {
      return await this._wallet.request(r);
    } catch (n) {
      throw console.error(n), new R();
    }
  }
  async disconnect() {
    if (!this.available() && !this._wallet)
      throw new S();
    M = null, ue = null, this._wallet = M, U();
  }
  async account(r) {
    if (this._wallet = M, !this._wallet)
      throw new A();
    if (!ue)
      throw new A();
    return new Account(r, ue, "");
  }
  async chainId() {
    if (!this._wallet)
      throw new A();
    const r = await this._wallet.request({
      type: "wallet_requestChainId"
    }), n = S2(r);
    return BigInt(n);
  }
  async initEventListener(r) {
    if (this._wallet = M, !this._wallet)
      throw new A();
    this._wallet.on("accountsChanged", r);
  }
  async removeEventListener(r) {
    if (this._wallet = M, !this._wallet)
      throw new A();
    this._wallet.off("accountsChanged", r), M = null, ue = null, this._wallet = null;
  }
  async ensureWallet() {
    const r = this._options.url || kr;
    Mt({
      origin: r,
      location: "/interstitialLogin"
    }), M = await to(r) ?? null, this._wallet = M;
  }
};
export {
  oo as WebWalletConnector
};
/*! Bundled license information:

starknetkit/dist/index-34c090a8.js:
  (* istanbul ignore if -- @preserve *)
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=starknetkit_webwallet.js.map
